<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASI平台专用AI助手 (导出格式最终修复)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            background-color: #f8fafc;
        }
        .prose-custom {
            color: #334155;
            line-height: 1.7;
        }
        .prose-custom h3 {
            color: #1e293b;
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
         .prose-custom h4 {
            color: #1e293b;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .prose-custom .content-block {
            white-space: pre-line;
            word-wrap: break-word;
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            position: relative;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #4f46e5;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        .mini-loader-inline {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4f46e5;
            border-radius: 50%;
            display: inline-block;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .history-item {
            transition: background-color 0.2s;
        }
        .history-item:hover {
            background-color: #f1f5f9;
        }
        .validation-msg {
            font-size: 0.8rem;
            font-weight: 500;
        }
        .input-group-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        .action-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            line-height: 1rem;
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            cursor: pointer;
            border: none;
        }
        .action-btn:hover {
            background-color: #e0e7ff;
        }
        .action-btn:disabled {
            background-color: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        .section-wrapper.locked {
            background-color: #f0f5ff;
            border-radius: 0.5rem;
            padding: 2px 8px;
            margin: -2px -8px;
        }
    </style>
</head>
<body class="bg-slate-100">
    <header class="text-center py-6 px-4">
        <h1 class="text-3xl md:text-4xl font-bold text-slate-900">ASI平台专用AI助手</h1>
        <p class="mt-2 text-slate-600">上传/粘贴图片、输入信息与参考文案，一键生成。</p>
    </header>

    <main class="lg:grid lg:grid-cols-2 lg:gap-8 p-4">
        <div class="lg:sticky lg:top-4 self-start">
             <div class="bg-white p-6 rounded-2xl shadow-lg relative flex flex-col h-[848px]">
                <div class="flex justify-between items-center pb-4 border-b mb-4 flex-shrink-0">
                    <h2 class="text-xl font-bold text-slate-800">产品信息</h2>
                    <div class="flex items-center gap-3">
                         <button id="clearAllBtn" class="text-sm bg-slate-200 text-slate-600 py-2 px-3 rounded-lg hover:bg-slate-300 transition" title="清空所有输入和结果">
                            清空内容
                        </button>
                        <button id="generateAllBtn" class="text-sm bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">
                            一键生成
                        </button>
                    </div>
                </div>
                 <div class="flex-grow overflow-y-auto custom-scrollbar pr-3 -mr-3">
                    <div class="mb-6">
                        <p class="input-group-title">1. 上传产品图片 (推荐)</p>
                        <div id="image-preview-container" class="hidden group relative w-48 h-48 mx-auto border-2 border-dashed rounded-lg flex items-center justify-center bg-slate-50">
                            <img id="image-preview" class="max-w-full max-h-full rounded-md">
                            <button id="remove-image-btn" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">&times;</button>
                        </div>
                         <div id="upload-box" class="mt-2">
                            <label for="imageUpload" class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-lg text-center transition block">
                                点击上传或直接粘贴图片
                            </label>
                            <input type="file" id="imageUpload" class="hidden" accept="image/png, image/jpeg, image/webp">
                        </div>
                    </div>

                    <div class="border-t pt-6">
                         <p class="input-group-title">2. 输入产品信息</p>
                        <div>
                            <label for="productIdea" class="block text-sm font-medium text-slate-700 mb-1">产品名称/概念</label>
                            <input type="text" id="productIdea" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="例如：带Logo的旅行保温杯">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                            <div>
                                <label for="productMaterial" class="block text-sm font-medium text-slate-700 mb-1">产品材质</label>
                                <input type="text" id="productMaterial" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="例如：304不锈钢, 竹盖">
                            </div>
                            <div>
                                <label for="productSpecs" class="block text-sm font-medium text-slate-700 mb-1">尺寸/规格</label>
                                <input type="text" id="productSpecs" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="例如：20oz (600ml), 高20cm">
                            </div>
                            <div class="md:col-span-2">
                                <label for="productScenarios" class="block text-sm font-medium text-slate-700 mb-1">核心卖点/使用场景</label>
                                <textarea id="productScenarios" rows="3" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="例如：双层真空，保冷12小时保热6小时。"></textarea>
                            </div>
                            <div class="md:col-span-2">
                                <label for="referenceText" class="block text-sm font-medium text-slate-700 mb-1">参考文案 (选填)</label>
                                <textarea id="referenceText" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="请粘贴参考的标题、描述或卖点..."></textarea>
                            </div>
                             <div class="md:col-span-2">
                                <label for="referenceKeywords" class="block text-sm font-medium text-slate-700 mb-1">参考关键词 (来自卖家精灵等, 选填)</label>
                                <textarea id="referenceKeywords" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="请粘贴关键词列表，用逗号或换行分隔..."></textarea>
                                <div class="mt-2">
                                     <button id="toggleCustomPromptBtn" class="text-sm font-medium text-indigo-600 hover:text-indigo-500 flex items-center gap-1">
                                        <span>自定义关键词规则</span>
                                        <svg id="customPromptArrow" class="w-4 h-4 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>
                                    </button>
                                </div>
                                <div id="customPromptContainer" class="mt-2 hidden">
                                     <textarea id="customKeywordPrompt" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm bg-indigo-50" placeholder="请在此处输入你对关键词生成的特殊要求。例如：&#10;1. 绝对不要出现任何品牌词，尤其是 [品牌A, 品牌B]。&#10;2. 多生成和‘商务礼品’、‘展会赠品’相关的词。"></textarea>
                                </div>
                             </div>
                        </div>
                    </div>
                </div>
             </div>
        </div>

        <div class="mt-8 lg:mt-0 flex flex-col h-[848px] gap-8">
            <div id="historySection" class="bg-white p-6 rounded-2xl shadow-lg flex-shrink-0">
                <div id="historyHeader" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-slate-800">历史记录</h2>
                    <div class="flex items-center gap-2">
                        <button id="exportAllBtn" class="text-sm bg-green-100 text-green-700 font-medium py-1 px-3 rounded-lg hover:bg-green-200 transition">批量导出</button>
                        <button id="clearHistoryBtn" class="text-sm bg-red-100 text-red-700 font-medium py-1 px-3 rounded-lg hover:bg-red-200 transition">清空历史</button>
                        <button id="toggleHistoryBtn" class="p-1 rounded-full hover:bg-slate-200 transition">
                            <svg id="history-arrow" class="w-5 h-5 text-slate-600 transition-transform transform -rotate-90" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor">
                              <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                            </svg>
                        </button>
                    </div>
                </div>
                <ul id="historyList" class="space-y-2 max-h-0 overflow-y-auto mt-0 transition-all duration-500 ease-in-out custom-scrollbar">
                </ul>
            </div>
            
            <div id="output" class="bg-white p-6 rounded-2xl shadow-lg flex-grow min-h-0 flex flex-col">
                 <div class="overflow-y-auto custom-scrollbar -mr-3 pr-3 h-full">
                    <div id="placeholder" class="text-center text-slate-500 flex flex-col items-center justify-center h-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-slate-400 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" /></svg>
                        <p>AI生成的内容将显示在这里...</p>
                    </div>
                    <div id="loader" class="loader hidden"></div>
                    <div id="result" class="prose-custom"></div>
                </div>
            </div>
        </div>
        
        <div id="messageBox" class="fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg hidden fade-in">
            <p id="messageText"></p>
        </div>

        <div id="apiKeyModal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center z-50 px-4">
            <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md m-4">
                <h2 class="text-2xl font-bold text-slate-800 mb-4">配置 API 密钥</h2>
                <p id="apiKeyMessage" class="text-slate-600 mb-4">为了使用AI功能，请输入您的 Google Gemini API 密钥。密钥将安全地存储在您的浏览器中。</p>
                <div class="mb-6">
                    <label for="apiKeyInput" class="block text-sm font-medium text-slate-700 mb-2">Gemini API Key</label>
                    <input type="password" id="apiKeyInput" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="在此输入您的密钥">
                </div>
                <div class="text-xs text-slate-500 mb-8">
                    不知道如何获取？ 
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="font-medium text-indigo-600 hover:text-indigo-500">
                        点击此处前往 Google AI Studio 获取
                    </a>
                </div>
                <div class="mt-8 flex justify-end">
                    <button id="saveApiKeyBtn" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition">保存密钥</button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // DOM Elements
        const generateAllBtn = document.getElementById('generateAllBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const outputDiv = document.getElementById('output');
        const placeholder = document.getElementById('placeholder');
        const loader = document.getElementById('loader');
        const resultDiv = document.getElementById('result');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const historyList = document.getElementById('historyList');
        const historyHeader = document.getElementById('historyHeader');
        const historyArrow = document.getElementById('history-arrow');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const exportAllBtn = document.getElementById('exportAllBtn');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageBtn = document.getElementById('remove-image-btn');
        const uploadBox = document.getElementById('upload-box');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyMessage = document.getElementById('apiKeyMessage');
        const toggleCustomPromptBtn = document.getElementById('toggleCustomPromptBtn');
        const customPromptContainer = document.getElementById('customPromptContainer');
        const customPromptArrow = document.getElementById('customPromptArrow');
        const customKeywordPrompt = document.getElementById('customKeywordPrompt');
        const productSpecsInput = document.getElementById('productSpecs'); 
        
        let history = [];
        let uploadedImageBase64 = null;
        let uploadedImageType = null;

        // Mapping for regeneration types to Chinese titles
        const REGEN_TYPE_MAP = { 
            'title': '产品名称', 
            'description': '产品描述', 
            'summary': '概要', 
            'keywords': '关键词' 
        };
        
        // Mapping for English titles to Chinese titles
        const ENGLISH_TITLE_MAP = {
            'Title': '产品名称',
            'Description': '产品描述',
            'Summary': '概要',
            'Keywords': '关键词'
        };

        // Reverse mapping for Chinese titles to English titles
        const REVERSE_ENGLISH_TITLE_MAP = Object.fromEntries(Object.entries(ENGLISH_TITLE_MAP).map(a => a.reverse()));


        // Event Listeners
        document.addEventListener('DOMContentLoaded', initApp); // Initialize app on DOM load
        generateAllBtn.addEventListener('click', () => handleGeneration('all')); // Generate all content
        clearAllBtn.addEventListener('click', clearAllInputs); // Clear all input fields
        clearHistoryBtn.addEventListener('click', clearHistory); // Clear history
        exportAllBtn.addEventListener('click', () => exportToExcel(history)); // Export history to Excel
        historyHeader.addEventListener('click', (e) => { // Toggle history visibility
            if (!e.target.closest('#clearHistoryBtn') && !e.target.closest('#exportAllBtn')) {
                toggleHistory();
            }
        });
        historyList.addEventListener('click', handleHistoryListClick); // Handle clicks on history items
        imageUpload.addEventListener('change', handleImageFile); // Handle image file upload
        removeImageBtn.addEventListener('click', removeImage); // Remove uploaded image
        document.addEventListener('paste', handlePaste); // Handle image paste from clipboard
        resultDiv.addEventListener('click', handleResultClick); // Handle clicks on generated result section
        saveApiKeyBtn.addEventListener('click', saveApiKey); // Save API key
        toggleCustomPromptBtn.addEventListener('click', toggleCustomPrompt); // Toggle custom keyword prompt visibility
        customKeywordPrompt.addEventListener('input', saveCustomPrompt); // Save custom prompt on input
        productSpecsInput.addEventListener('input', handleProductSpecsInput); // Handle product specs input (for potential future enhancements)


        // Initialize the application
        function initApp() {
            loadHistory(); // Load saved history
            const savedKey = localStorage.getItem('geminiApiKey');
            if (!savedKey) {
                showApiKeyModal('欢迎使用！请先配置您的API密钥。'); // Prompt for API key if not found
            }
            loadCustomPrompt(); // Load custom keyword prompt
        }
        
        // Load custom keyword prompt from local storage
        function loadCustomPrompt() {
            const savedPrompt = localStorage.getItem('customKeywordPrompt');
            if (savedPrompt) {
                customKeywordPrompt.value = savedPrompt;
            }
        }

        // Save custom keyword prompt to local storage
        function saveCustomPrompt() {
            localStorage.setItem('customKeywordPrompt', customKeywordPrompt.value);
        }

        // Toggle visibility of custom keyword prompt
        function toggleCustomPrompt() {
            customPromptContainer.classList.toggle('hidden');
            customPromptArrow.classList.toggle('rotate-180');
        }

        // Display API key modal with a given message
        function showApiKeyModal(message) {
            apiKeyMessage.textContent = message || '为了使用AI功能，请输入您的 Google Gemini API 密钥。密钥将仅存储在您的浏览器本地。';
            apiKeyModal.classList.remove('hidden');
            // Ensure the modal is visible and on top
            apiKeyModal.style.display = 'flex';
            apiKeyInput.focus(); // Focus on the input field
        }

        // Save API key to local storage
        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                apiKeyModal.style.display = 'none'; // Hide modal
                showMessage('API密钥已保存！', 'success');
            } else {
                showMessage('请输入有效的API密钥。', 'error');
            }
        }

        // Handle image file selection
        function handleImageFile(event) {
            const file = event.target.files[0];
            if (file) processImageFile(file);
        }
        
        // Handle image paste from clipboard
        function handlePaste(event) {
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    event.preventDefault(); // Prevent default paste behavior
                    processImageFile(item.getAsFile());
                    break; 
                }
            }
        }

        // Process the image file (read as Data URL and display preview)
        function processImageFile(file) {
             if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedImageBase64 = e.target.result.split(',')[1]; // Get base64 data
                uploadedImageType = file.type; // Get image type
                imagePreview.src = e.target.result; // Set image preview source
                imagePreviewContainer.classList.remove('hidden'); // Show preview container
                uploadBox.classList.add('hidden'); // Hide upload box
            };
            reader.readAsDataURL(file); // Read file as Data URL
        }

        // Remove the uploaded image
        function removeImage() {
            uploadedImageBase64 = null;
            uploadedImageType = null;
            imagePreview.src = '';
            imageUpload.value = ''; // Clear file input
            imagePreviewContainer.classList.add('hidden'); // Hide preview container
            uploadBox.classList.remove('hidden'); // Show upload box
        }
        
        // Clear all input fields and results
        function clearAllInputs() {
            removeImage(); // Remove image
            document.getElementById('productIdea').value = '';
            document.getElementById('productMaterial').value = '';
            document.getElementById('productSpecs').value = '';
            document.getElementById('productScenarios').value = '';
            document.getElementById('referenceText').value = '';
            document.getElementById('referenceKeywords').value = '';
            resultDiv.innerHTML = ''; // Clear result display
            placeholder.classList.remove('hidden'); // Show placeholder
            generateAllBtn.innerHTML = '一键生成'; // Reset generate button text
            showMessage('所有内容已清空。', 'success');
        }
        
        // Handle clicks within the result display area (regenerate, copy, translate, lock)
        function handleResultClick(event) {
            const regenBtn = event.target.closest('.regenerate-btn');
            const copyBtn = event.target.closest('.copy-btn');
            const translateBtn = event.target.closest('.translate-btn');
            const lockBtn = event.target.closest('.lock-btn');

             if (regenBtn) {
                const type = regenBtn.dataset.type;
                handleSingleRegeneration(type); // Regenerate a single section
            } else if (copyBtn) {
                const contentBlock = copyBtn.closest('.section-wrapper').querySelector('.content-block');
                const textToCopy = getCleanTextFromBlock(contentBlock);
                copyToClipboard(textToCopy); // Copy content to clipboard
            } else if (translateBtn) {
                const contentBlock = translateBtn.closest('.section-wrapper').querySelector('.content-block');
                const textToTranslate = getCleanTextFromBlock(contentBlock);
                openGoogleTranslate(textToTranslate); // Open content in Google Translate
            } else if (lockBtn) {
                toggleLock(lockBtn); // Toggle section lock state
            }
        }
        
        // Extract clean text from a content block, handling <br> tags
        function getCleanTextFromBlock(contentBlock) {
            if (!contentBlock) return '';
            const clone = contentBlock.cloneNode(true);

            // Remove the counter div before extracting text
            const counter = clone.querySelector('.absolute.bottom-2.right-2');
            if (counter) {
                counter.remove();
            }

            let textContent = '';
            // Iterate through child nodes to explicitly handle <br> tags
            clone.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    // For text nodes, append their content
                    textContent += node.textContent;
                } else if (node.tagName === 'BR') {
                    // For <br> tags, append a newline character
                    textContent += '\n';
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // For other element nodes (e.g., nested spans, though unlikely in content-block),
                    // recursively get their innerText.
                    textContent += node.innerText; 
                }
            });

            return textContent.trim();
        }

        // Toggle the lock state of a content section
        function toggleLock(lockBtn) {
            const section = lockBtn.closest('.section-wrapper');
            const isLocked = section.classList.toggle('locked');
            const regenBtn = section.querySelector('.regenerate-btn');
            
            // Update lock button icon and text
            lockBtn.innerHTML = isLocked ? 
                `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg><span>锁定</span>` :
                `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 = 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2"/></svg><span>解锁</span>`;
            
            lockBtn.setAttribute('title', isLocked ? '点击解锁' : '点击锁定');
            if (regenBtn) {
                regenBtn.disabled = isLocked; // Disable regenerate button if locked
            }
        }

        // Open content in Google Translate
        function openGoogleTranslate(text) {
            const encodedText = encodeURIComponent(text);
            const url = `https://translate.google.com/?sl=en&tl=zh-CN&text=${encodedText}&op=translate`;
            window.open(url, '_blank');
        }

        // Copy text to clipboard
        function copyToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showMessage('已复制到剪贴板！', 'success');
            } catch (err) {
                showMessage('复制失败！', 'error');
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textArea);
        }
        
        // Extract clean content by removing markdown headers
        function extractCleanContent(rawText) {
             if (!rawText) return '';
             return rawText.replace(/^###\s+(Title|Summary|Description|Keywords)\s*\n---\n?/, '').trim();
        }

        // Handle overall content generation (all sections or unlocked sections)
        async function handleGeneration(type) {
            const productIdea = document.getElementById('productIdea').value.trim();
            if (!productIdea) {
                showMessage('请输入产品名称/概念。', 'error');
                return;
            }

            const sections = Array.from(resultDiv.querySelectorAll('.section-wrapper'));
            const lockedContent = new Map();
            const unlockedTypes = new Set(['title', 'description', 'summary', 'keywords']);

            // Identify locked sections and their content
            sections.forEach(section => {
                if (section.classList.contains('locked')) {
                    const type = section.querySelector('.regenerate-btn')?.dataset.type;
                    if (type) {
                        lockedContent.set(type, section.innerHTML);
                        unlockedTypes.delete(type);
                    }
                }
            });

            // If all sections are locked, no generation is needed
            if (unlockedTypes.size === 0 && sections.length > 0) {
                showMessage('所有模块都已锁定，无需生成。', 'info');
                return;
            }

            const typesToGenerate = Array.from(unlockedTypes);
            if (typesToGenerate.length === 0) {
                typesToGenerate.push('all'); // If no unlocked types, generate all (first run or all were locked then unlocked)
            }

            // Gather product details from input fields
            const material = document.getElementById('productMaterial').value.trim();
            let specs = document.getElementById('productSpecs').value.trim(); // Get raw specs
            const scenarios = document.getElementById('productScenarios').value.trim();
            const referenceText = document.getElementById('referenceText').value.trim();
            const referenceKeywords = document.getElementById('referenceKeywords').value.trim();
            const customKeywordText = customKeywordPrompt.value.trim();

            // Convert cm to inches for prompt if 'cm' is present in specs
            const cmToInchConversion = convertCmToInches(specs);
            if (cmToInchConversion) {
                specs = cmToInchConversion; // Use the formatted string for the prompt
            }

            const details = { material, specs, scenarios, referenceText, referenceKeywords, customKeywordPrompt: customKeywordText };
            
            // Determine generation mode based on number of types to generate
            const generationMode = typesToGenerate.length >= 4 ? 'all' : typesToGenerate.join(',');
            const prompt = createPrompt(generationMode, productIdea, details);

            showLoading(true); // Show loading indicator
            try {
                const text = await callGeminiAPI(prompt, uploadedImageBase64, uploadedImageType);
                
                // Merge new results with locked content
                if (lockedContent.size > 0) {
                    const newResultHtml = parseAndMergeResults(text, lockedContent, productIdea);
                    resultDiv.innerHTML = newResultHtml;
                } else {
                    displayResult(text, 'all', productIdea); // Display all new results
                }
                
                // Save the full content to history
                const fullContentForHistory = resultDiv.innerHTML;
                const fullTextContent = convertHtmlToStructuredText(fullContentForHistory);
                await saveToHistory(productIdea, fullTextContent, details, uploadedImageBase64, uploadedImageType);
                
                generateAllBtn.innerHTML = '🚀 重新生成'; // Update button text

            } catch (error) {
                console.error('API Call Error:', error);
                const errorMessage = error.message || '未知错误';
                displayResult(`抱歉，调用AI服务时出错：${errorMessage}`, 'error'); // Display error message
                showMessage(`AI服务调用失败: ${errorMessage}`, 'error');

                // If API key is invalid, show modal
                if (errorMessage.includes('401') || errorMessage.includes('API密钥') || errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key expired')) {
                    showApiKeyModal('API密钥无效或缺失，请更新或添加密钥。');
                }

            } finally {
                showLoading(false); // Hide loading indicator
            }
        }
        
        // Handle regeneration of a single content section
        async function handleSingleRegeneration(type) {
            const productIdea = document.getElementById('productIdea').value.trim();
            if (!productIdea) {
                showMessage('无法在没有产品概念的情况下重新生成。', 'error');
                return;
            }

            // Gather product details (same as handleGeneration)
            const material = document.getElementById('productMaterial').value.trim();
            let specs = document.getElementById('productSpecs').value.trim();
            const scenarios = document.getElementById('productScenarios').value.trim();
            const referenceText = document.getElementById('referenceText').value.trim();
            const referenceKeywords = document.getElementById('referenceKeywords').value.trim();
            const customKeywordText = customKeywordPrompt.value.trim();

            const cmToInchConversion = convertCmToInches(specs);
            if (cmToInchConversion) {
                specs = cmToInchConversion;
            }

            const details = { material, specs, scenarios, referenceText, referenceKeywords, customKeywordText: customKeywordText };

            const sectionTitle = REGEN_TYPE_MAP[type];
            const sectionWrapper = document.getElementById(`section-${sectionTitle.replace(/\s/g, '-')}`);
            if (!sectionWrapper) return;

            const regenerateButton = sectionWrapper.querySelector('.regenerate-btn');
            
            // Show mini loader and disable button during regeneration
            if (regenerateButton) {
                regenerateButton.innerHTML = `<span class="mini-loader-inline"></span>`;
                regenerateButton.disabled = true;
            }

            const prompt = createPrompt(type, productIdea, details);

            try {
                const rawText = await callGeminiAPI(prompt, uploadedImageBase64, uploadedImageType);
                let newCleanText = extractCleanContent(rawText);

                newCleanText = enforceContentLimits(sectionTitle, newCleanText); // Enforce content limits

                const contentBlock = sectionWrapper.querySelector('.content-block');
                contentBlock.innerText = newCleanText; // Update content
                
                const counterDiv = createCounterDiv(sectionTitle, newCleanText); // Update counter
                if (counterDiv) contentBlock.appendChild(counterDiv);

                const validationResult = validateContent(sectionTitle, newCleanText); // Validate content
                const statusSpan = sectionWrapper.querySelector('.validation-status');
                if(statusSpan) {
                     statusSpan.innerHTML = getValidationStatus(validationResult); // Update validation status
                }
                
                await updateHistoryContent(productIdea, sectionTitle, newCleanText); // Update history
            } catch (error) {
                 const errorMessage = error.message || '未知错误';
                 showMessage(`重新生成'${sectionTitle}'失败: ${errorMessage}`, 'error');
                 if (errorMessage.includes('401') || errorMessage.includes('API密钥') || errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key expired')) {
                    showApiKeyModal('API密钥无效或缺失，请更新或添加密钥。');
                 }
            } finally {
                 // Restore regenerate button state
                 if (regenerateButton) {
                    regenerateButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg><span>重新生成</span>`;
                    regenerateButton.disabled = false;
                }
            }
        }

        /**
         * Converts centimeters to inches within a given string.
         * Looks for patterns like "10cm", "20 cm", "30.5cm", etc.
         * @param {string} specsString The input string containing specifications.
         * @returns {string} The updated string with cm values converted to inches and appended, or original string if no cm found.
         */
        function convertCmToInches(specsString) {
            if (!specsString) return '';
            let convertedString = specsString;
            // Regex to find numbers followed by 'cm' or ' cm'
            const cmRegex = /(\d+(\.\d+)?)\s*cm/gi; 
            let match;
            let replacements = [];

            // Find all matches and store them
            while ((match = cmRegex.exec(specsString)) !== null) {
                const cmValue = parseFloat(match[1]);
                if (!isNaN(cmValue)) {
                    const inchValue = (cmValue / 2.54).toFixed(2); // Convert to inches, 2 decimal places
                    replacements.push({
                        original: match[0],
                        replacement: `${match[0]} (approx ${inchValue} inches)`
                    });
                }
            }

            // Apply replacements from back to front to avoid index issues
            for (let i = replacements.length - 1; i >= 0; i--) {
                const rep = replacements[i];
                // Use a global regex to replace all occurrences, but only the specific matched string
                convertedString = convertedString.split(rep.original).join(rep.replacement);
            }

            return convertedString;
        }

        // This function is currently not modifying the input field directly,
        // as the request was to include it in the *description* generated by AI.
        // If direct input field modification is desired, this is where it would go.
        function handleProductSpecsInput() {
            // No direct modification of input field here.
        }

        // Create the prompt string for the Gemini API call
        function createPrompt(type, product, details) {
            let productDetailsSection = "\n**Product Details (Use these text details to supplement the provided image):**";
            let hasDetails = false;
            if (details.material) { productDetailsSection += `\n- Material: ${details.material}`; hasDetails = true; }
            // Use the potentially converted specs for the prompt
            if (details.specs) { productDetailsSection += `\n- Specifications: ${details.specs}`; hasDetails = true; } 
            if (details.scenarios) { productDetailsSection += `\n- Key Selling Points/Scenarios: ${details.scenarios}`; hasDetails = true; }
            if (details.referenceText) {
                productDetailsSection += `\n- **Reference Text (Crucial):** """${details.referenceText}"""`;
                hasDetails = true;
            }
             if (details.referenceKeywords) {
                productDetailsSection += `\n- **Reference Keywords (High Priority):** """${details.referenceKeywords}"""`;
                hasDetails = true;
            }

            const basePrompt = `You are an expert copywriter for the B2B promotional products platform ASI. Your primary role is to act as a market researcher and content generator.\n\n**Step 1: Simulated Web Research.**\nBased on the user's 'Product Concept', you must first perform a simulated web search on popular e-commerce sites (like Amazon.com) and promotional product platforms (like ASI, 4imprint) to gather typical features, materials, specifications, and marketing angles for this type of product. You must use this simulated research as the primary context for your writing, especially if the user has not provided detailed reference text. For example, if the user enters "umbrella", you should imagine searching for "promotional travel umbrella" and "custom logo umbrella" and use the common features you find (e.g., auto-open, fiberglass ribs, SPF 50+ canopy) to enrich your output.\n\n**Step 2: Content Generation.**\nUsing the context from your research AND the specific details provided by the user, generate the required content. User-provided details (like material, specs, reference text) ALWAYS take precedence over your general research.\n\n**User's Input:**\n- Product Concept: ${product}${hasDetails ? productDetailsSection : ''}\n\n**CRUCIAL, UNBREAKABLE RULES:**\n- **ALL OUTPUT MUST BE IN ENGLISH.** Do not include any Chinese characters or any other language in the output.\n- **YOUR RESPONSE MUST START DIRECTLY WITH '### Title'.** Any other starting text, preamble, or conversational filler will cause a system crash.`;
            
            const titleRules = `**Title Rules:**\n1. Generate 5 unique product names. Each on a new line.\n2. Each name MUST be Title Case (first letter of each word capitalized).\n3. Each name MUST be under 60 characters.\n4. A name MUST NOT contain any repeated words.`;
            const summaryRules = `**Summary Rules:**\n1. Generate one concise paragraph summarizing the product's key highlights.\n2. The summary MUST be a complete, grammatically correct sentence. Prioritize sentence completeness over hitting the exact 130-character limit. It should be under 130 characters.`; // Modified rule
            const descriptionRules = `**Description Rules:**\n1. The description MUST be under 800 characters.\n2. It MUST NOT contain any Chinese punctuation. Use only standard English punctuation.\n3. It MUST NOT contain any price-related language (e.g., "$", "price", "cost").\n4. Structure the paragraph around: Material, Function, Usage Scenarios, Advantages, and an assurance statement.`;
            
            let keywordRules = `**Keywords Rules:**
**ABSOLUTE PRIMARY RULES (THIS IS A NON-NEGOTIABLE FINAL CHECK):**
1. **The final output MUST contain EXACTLY 30 keyword groups.** Not 29, not 31. Exactly 30.
2. **Each of the 30 groups MUST be under 30 characters.** This is a strict platform limit.

**Formatting and Content Rules:**
3. Each group MUST be separated by a comma and a space (e.g., "Word One, Word Two").
4. Each group MUST be Title Case.
5. Each group MUST be a short phrase, ideally 2-3 words. Do not write full sentences.
6. Use relevant terms a customer would search for. DO NOT use irrelevant words.
7. DO NOT repeat phrases already used in the Title, Summary, or Description.
8. DO NOT stuff or repeat keywords.
9. DO NOT use plurals, symbols, or abbreviations.
10. DO NOT use subjective praise (e.g., "Best", "Amazing").
11. **Crucially, use the "Reference Keywords" as the primary source.** Clean them up to meet all rules above. If the cleaned reference list is not enough, generate more relevant, non-brand keywords to reach exactly 30 groups. Actively identify and exclude any potential brand names or trademarks.`;
            
            if (details.customKeywordPrompt) {
                keywordRules += `\n\n**--- CRITICAL USER-DEFINED RULES OVERRIDE ---\nTHE FOLLOWING INSTRUCTIONS OVERRIDE ANY PREVIOUS RULES FOR KEYWORDS. YOU MUST FOLLOW THEM PRECISELY, WHILE STILL RESPECTING THE ABSOLUTE PRIMARY RULES ABOVE:**\n"""\n${details.customKeywordPrompt}\n"""`;
            }

            const typeRulesMap = { 'title': titleRules, 'description': descriptionRules, 'summary': summaryRules, 'keywords': keywordRules };
            const englishHeaders = { 'title': 'Title', 'description': 'Description', 'summary': 'Summary', 'keywords': 'Keywords'};

            let taskDescription = '';
            let rulesDescription = '';
            const typesToGenerate = type.split(',').filter(t => t && t !== 'all');

            if (type === 'all' || typesToGenerate.length >= 4) {
                 taskDescription = `**Task: Generate all content sections: Title, Description, Summary, and Keywords.**`;
                 rulesDescription = `**Output Structure & Rules:**\nFollow this structure precisely. Do not add any text before "### Title".\n\n### Title\n---\n[5 names, each on a new line]\n\n### Description\n---\n[1 paragraph]\n\n### Summary\n---\n[1 paragraph]\n\n### Keywords\n---\n[30 comma-separated groups]\n\n${titleRules}\n${descriptionRules}\n${summaryRules}\n${keywordRules}`;
            } else {
                taskDescription = `**Task: Generate ONLY the following sections: ${typesToGenerate.map(t => englishHeaders[t]).join(', ')}.**`;
                rulesDescription = `**Output Structure & Rules:**\n` + typesToGenerate.map(t => `### ${englishHeaders[t]}\n---\n[Content for ${englishHeaders[t]}]\n\n${typeRulesMap[t]}`).join('\n\n');
            }

            return `${basePrompt}\n\n${taskDescription}\n\n${rulesDescription}`;
        }
        
        // Enforce content length and format limits based on content type
        function enforceContentLimits(chineseTitle, text) {
            let enforcedText = text;
            switch (chineseTitle) {
                case '概要':
                    // If the text is longer than 130 characters, try to truncate at the last full stop or word boundary.
                    if (enforcedText.length > 130) {
                        let truncated = enforcedText.substring(0, 130);
                        let lastFullStop = truncated.lastIndexOf('.');
                        let lastSpace = truncated.lastIndexOf(' ');

                        if (lastFullStop !== -1 && lastFullStop > truncated.length - 20) { // If a full stop is near the end
                            enforcedText = truncated.substring(0, lastFullStop + 1);
                        } else if (lastSpace !== -1 && lastSpace > truncated.length - 20) { // If a space is near the end
                            enforcedText = truncated.substring(0, lastSpace);
                        } else {
                            // Fallback to simple truncation if no good boundary is found near the limit
                            enforcedText = truncated;
                        }
                    }
                    break;
                case '关键词':
                    let keywords = enforcedText.split(',').map(k => k.trim()).filter(Boolean);
                    if (keywords.length > 30) {
                        keywords = keywords.slice(0, 30);
                    }
                    keywords = keywords.map(kw => {
                        if (kw.length > 30) {
                            let truncatedKw = kw.substring(0, 30);
                            return truncatedKw.substring(0, Math.min(truncatedKw.length, truncatedKw.lastIndexOf(' ')) || truncatedKw.length);
                        }
                        return kw;
                    });
                    enforcedText = keywords.join(', ');
                    break;
            }
            return enforcedText;
        }

        // Validate content against defined rules
        function validateContent(chineseTitle, text) {
            const results = { isValid: true, messages: [] };
             if (/[一-龠]/.test(text)) { // Check for Chinese characters
                results.isValid = false; 
                results.messages.push(`包含中文`); 
            }
            switch (chineseTitle) {
                case '产品名称':
                    // No specific validation rules beyond general Chinese character check
                    break;
                case '概要':
                     // Changed validation to check for a full stop at the end for sentence completeness
                    if (text.length > 130) { 
                        results.isValid = false; 
                        results.messages.push(`概要超长 (${text.length}/130)`); 
                    }
                    if (!text.endsWith('.') && text.length > 0) { // Check for full stop at the end if not empty
                        results.isValid = false;
                        results.messages.push(`非完整句子`);
                    }
                    break;
                case '产品描述':
                    if (text.length > 800) { results.isValid = false; results.messages.push(`描述超长 (${text.length}/800)`); }
                    if (/[，。！？；：]/.test(text)) { results.isValid = false; results.messages.push(`含中文标点`); } // Check for Chinese punctuation
                    break;
                case '关键词':
                    const keywords = text.split(',').map(k => k.trim()).filter(Boolean);
                    if (keywords.length !== 30) { results.isValid = false; results.messages.push(`组数: ${keywords.length} (应为30)`); }
                    
                    const longKeywords = keywords.filter(kw => kw.length > 30);
                    if (longKeywords.length > 0) {
                        results.isValid = false;
                        results.messages.push(`关键词超长 (${longKeywords[0].length}/30)`);
                    }
                    break;
            }
            return results;
        }
        
        // Get validation status HTML string
        function getValidationStatus(validationResult) {
            if (!validationResult.isValid) {
                const message = validationResult.messages.join(', ');
                return `<span class="validation-msg text-red-500">(⚠️ ${message})</span>`;
            }
            return '<span class="text-green-500">✅</span>';
        }

        // Create a counter div for content length/count
        function createCounterDiv(chineseTitle, content) {
            let countHtml = '';
             switch (chineseTitle) {
                case '概要':
                    countHtml = `${content.length} / 130`;
                    break;
                case '产品描述':
                    countHtml = `${content.length} / 800`;
                    break;
                case '关键词':
                    const keywordCount = content.split(',').filter(Boolean).length;
                    countHtml = `${keywordCount} / 30 组`;
                    break;
            }

            if (countHtml) {
                const countDiv = document.createElement('div');
                countDiv.className = 'absolute bottom-2 right-2 text-xs text-slate-400';
                countDiv.textContent = countHtml;
                return countDiv;
            }
            return null;
        }

        // Toggle history list visibility
        function toggleHistory() {
            historyList.classList.toggle('max-h-0');
            historyList.classList.toggle('mt-0');
            historyList.classList.toggle('max-h-96');
            historyList.classList.toggle('mt-4');
            historyArrow.classList.toggle('rotate-180');
        }
        
        // Compress image for history storage (thumbnail)
        async function compressImage(src, maxWidth = 200, maxHeight = 200, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                    } else {
                        if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    const dataUrl = canvas.toDataURL('image/jpeg', quality);
                    const [header, base64Data] = dataUrl.split(',');
                    resolve({ base64: base64Data, type: 'image/jpeg' });
                };
                img.onerror = (error) => reject(error);
            });
        }
        
        // Load history from local storage
        function loadHistory() {
            try {
                const storedHistory = localStorage.getItem('asiProductHistory');
                if (storedHistory) { history = JSON.parse(storedHistory); renderHistory(); }
            } catch (e) { console.error("Failed to load history:", e); localStorage.removeItem('asiProductHistory'); }
        }

        // Render history list items
        function renderHistory() {
            historyList.innerHTML = '';
            if(history.length === 0){
                historyList.innerHTML = `<li class="text-slate-400 text-center text-sm p-4">暂无历史记录</li>`;
                return;
            }
            history.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'history-item flex justify-between items-center p-3 rounded-lg border border-slate-200';
                li.dataset.index = index;
                li.innerHTML = `
                    <span class="truncate cursor-pointer flex-grow history-item-view" title="${item.product}">${item.product}</span>
                    <button class="history-item-export ml-4 text-xs bg-blue-100 text-blue-700 font-medium py-1 px-2 rounded-md hover:bg-blue-200 transition-colors flex-shrink-0" data-index="${index}">导出</button>
                `;
                historyList.appendChild(li);
            });
        }

        // Handle clicks on history list (view or export)
        function handleHistoryListClick(event) {
            const target = event.target;
            const viewTarget = target.closest('.history-item-view');
            const exportTarget = target.closest('.history-item-export');

            if (exportTarget) {
                const index = exportTarget.dataset.index;
                const itemToExport = history[index];
                if (itemToExport) {
                    exportToExcel([itemToExport]);
                }
            } else if (viewTarget) {
                 const li = viewTarget.closest('.history-item');
                 const index = li.dataset.index;
                 viewHistoryItem(index);
            }
        }
        
        // Save current generation to history
        async function saveToHistory(product, content, details, fullResImageBase64, fullResImageType) {
            const existingIndex = history.findIndex(item => item.product === product);
            if (existingIndex > -1) history.splice(existingIndex, 1); // Remove existing entry if product name matches
            
            let thumbnailImage = { base64: null, type: null };
            if (fullResImageBase64 && fullResImageType) {
                const dataUrl = `data:${fullResImageType};base64,${fullResImageBase64}`;
                try {
                    thumbnailImage = await compressImage(dataUrl, 200, 200, 0.7); // Compress image for thumbnail
                } catch (e) {
                    console.error("Image compression for history failed:", e);
                    thumbnailImage = { base64: null, type: null };
                }
            }

            history.unshift({ // Add to the beginning of history
                product,
                content,
                details,
                imageBase64: thumbnailImage.base64,
                imageType: thumbnailImage.type
            });

            try {
                if (history.length > 50) history.pop(); // Keep history limited to 50 items
                localStorage.setItem('asiProductHistory', JSON.stringify(history)); // Save to local storage
            } catch (e) {
                showMessage('历史记录存储失败，可能已满。', 'error');
                console.error("Failed to save history to localStorage:", e);
                history.shift(); // Remove the added item if storage fails
            }
            renderHistory(); // Re-render history list
        }

        // Update content of an existing history item
        async function updateHistoryContent(product, chineseTitle, newContent) {
             const existingIndex = history.findIndex(item => item.product === product);
            if (existingIndex > -1) {
                const currentItem = history[existingIndex];
                const englishTitle = REVERSE_ENGLISH_TITLE_MAP[chineseTitle];
                if (!englishTitle) return;

                // Use regex to find and replace the specific section content
                const regex = new RegExp(`(### ${englishTitle}\\n---)([\\s\\S]*?)(?=\\n###|$)`);
                const updatedContent = currentItem.content.replace(regex, `$1\n${newContent.trim()}\n`);
                history[existingIndex].content = updatedContent;
                try {
                    localStorage.setItem('asiProductHistory', JSON.stringify(history));
                } catch (e) {
                     console.error("Failed to update history in localStorage:", e);
                }
            }
        }

        // View a history item (load its content into the main input/output areas)
        function viewHistoryItem(index) {
            const item = history[index];
            if (item) {
                clearAllInputs(); // Clear current inputs

                // Populate input fields
                document.getElementById('productIdea').value = item.product || '';
                if(item.details){
                    document.getElementById('productMaterial').value = item.details.material || '';
                    document.getElementById('productSpecs').value = item.details.specs || '';
                    document.getElementById('productScenarios').value = item.details.scenarios || '';
                    document.getElementById('referenceText').value = item.details.referenceText || '';
                    document.getElementById('referenceKeywords').value = item.details.referenceKeywords || '';
                }

                const imageB64 = item.originalImageBase64 || item.imageBase64; // Use original if available, else thumbnail
                const imageT = item.originalImageType || item.imageType;
                
                if (imageB64 && imageT) {
                    const dataUrl = `data:${imageT};base64,${imageB64}`;
                    processImageFile(dataURLtoFile(dataUrl, item.product)); // Load image
                }
                
                displayResult(item.content, 'all', item.product); // Display generated content
                generateAllBtn.innerHTML = '🚀 重新生成'; // Update button text
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top
            }
        }

        // Clear all history
        function clearHistory() {
            history = [];
            localStorage.removeItem('asiProductHistory');
            renderHistory();
            showMessage('历史记录已清空。', 'success');
        }
        
        // Show/hide loading indicator
        function showLoading(isLoading) {
            loader.classList.toggle('hidden', !isLoading);
            if (isLoading) { placeholder.classList.add('hidden'); resultDiv.innerHTML = ''; }
        }
        
        // Build HTML for a single content section
        function buildSectionHtml(chineseTitle, rawContent) {
            let content = enforceContentLimits(chineseTitle, rawContent);

            // Apply cm to inch conversion for '概要' (Summary) if it contains cm
            if (chineseTitle === '概要') {
                content = convertCmToInches(content);
            }

            const regenType = Object.keys(REGEN_TYPE_MAP).find(key => REGEN_TYPE_MAP[key] === chineseTitle);
            
            const validationResult = validateContent(chineseTitle, content);
            const status = getValidationStatus(validationResult);

            // Buttons for interaction
            const lockButton = `<button class="lock-btn action-btn" title="点击锁定" data-type="${regenType}"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg><span>解锁</span></button>`;
            const translateButton = `<button class="translate-btn action-btn" title="在谷歌翻译中打开"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286zm1.634-2.736L5.5 1.956h-.043l-.697 2.022z"/><path d="M0 2a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v3h3a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3H2a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v7a1 1 0 = 0 1 1h7a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.17.302.278.632.365.992.508-.283.92-1.075 1.21-1.96.28-.85.455-1.85.508-2.934h-1.025c-.05.88-.17 1.56-.34 2.11a2.7 2.7 0 0 1-.62 1.087c-.22.252-.494.456-.79.612z"/></svg><span>翻译</span></button>`;
            const copyButton = `<button class="copy-btn action-btn" title="复制内容"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/><path d="M5.5 1a.5.5 0 0 1 .5.5V2h6v-.5a.5.5 0 0 1 1 0V2A1.5 1.5 0 0 1 11.5 3.5h-7A1.5 1.5 0 0 1 3 2V1.5a.5.5 0 0 1 .5-.5zM5 3.5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 0-1h-5a.5.5 0 0 0-.5.5"/></svg><span>复制</span></button>`;
            const regenButton = `<button class="regenerate-btn action-btn" data-type="${regenType}" title="重新生成此版块"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg><span>重新生成</span>`;
            const counterDiv = createCounterDiv(chineseTitle, content);

            return `<div class="section-wrapper" id="section-${chineseTitle.replace(/\s/g, '-')}">
                        <h4>
                            <span>${chineseTitle}</span>
                            <span class="validation-status">${status}</span>
                            <div class="ml-auto flex items-center gap-2">${lockButton}${translateButton}${copyButton}${regenButton}</div>
                        </h4>
                        <div class="content-block">
                            ${content.replace(/\n/g, '<br>')}
                            ${counterDiv ? counterDiv.outerHTML : ''}
                        </div>
                     </div>`;
        }

        // Parse new AI generated text and merge with existing locked content
        function parseAndMergeResults(newText, lockedContentMap, productIdea) {
            let html = `<h3>${productIdea}</h3>`;
            const allTypes = ['title', 'description', 'summary', 'keywords'];
            
            const newSections = new Map();
            const startIndex = newText ? newText.indexOf('###') : -1;
            
            if (startIndex !== -1) {
                const cleanText = newText.substring(startIndex);
                const sections = cleanText.split(/### (Title|Summary|Description|Keywords)\n---/g).filter(s => s && s.trim() !== '');
                for (let i = 0; i < sections.length; i += 2) {
                     if (sections[i + 1] === undefined) continue; // Skip if content is missing
                     const englishTitle = sections[i].trim();
                     const regenType = englishTitle.toLowerCase();
                     newSections.set(regenType, sections[i+1].trim());
                }
            }

            allTypes.forEach(regenType => {
                if (lockedContentMap.has(regenType)) {
                    html += lockedContentMap.get(regenType); // Use locked content
                } else {
                    const content = newSections.get(regenType) || '生成失败或无内容返回';
                    const chineseTitle = REGEN_TYPE_MAP[regenType];
                    html += buildSectionHtml(chineseTitle, content); // Build new section HTML
                }
            });

            return html;
        }

        // Display the generated result in the output area
        function displayResult(text, type, productIdea = '') {
            placeholder.classList.add('hidden');
            let html = `<h3>${productIdea}</h3>`;
            const startIndex = text ? text.indexOf('###') : -1;
            
            if (type === 'error') {
                html += `<div class="content-block text-red-600">${text}</div>`;
            } else if (startIndex === -1) {
                html += `<h4>AI 原始回复 (格式错误)</h4><div class="content-block">${text || '无内容返回'}</div>`;
            } else {
                const cleanText = text.substring(startIndex);
                // Split by markdown headers
                const sections = cleanText.split(/### (Title|Summary|Description|Keywords)\n---/g).filter(s => s && s.trim() !== '');
                
                for (let i = 0; i < sections.length; i += 2) {
                    const englishTitle = sections[i].trim();
                     if (sections[i + 1] === undefined) {
                        console.warn(`Content missing for section: ${englishTitle}`);
                        continue; 
                    }
                    const content = sections[i + 1].trim();
                    const chineseTitle = ENGLISH_TITLE_MAP[englishTitle] || englishTitle;
                    html += buildSectionHtml(chineseTitle, content); // Build HTML for each section
                }
            }
            resultDiv.innerHTML = html;
        }

        // Convert displayed HTML content back to structured plain text for history
        function convertHtmlToStructuredText(htmlContent) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            let structuredText = '';
            const sections = tempDiv.querySelectorAll('.section-wrapper');
            sections.forEach(section => {
                const chineseTitle = section.querySelector('h4 span:first-child').textContent.trim();
                const englishTitle = REVERSE_ENGLISH_TITLE_MAP[chineseTitle] || chineseTitle;
                const content = getCleanTextFromBlock(section.querySelector('.content-block'));
                structuredText += `### ${englishTitle}\n---\n${content}\n\n`;
            });
            return structuredText.trim();
        }

        // Show a temporary message box
        function showMessage(message, type = 'success') {
            messageText.textContent = message;
            messageBox.className = 'fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg fade-in';
            if (type === 'error') messageBox.classList.add('bg-red-500');
            else if (type === 'info') messageBox.classList.add('bg-blue-500');
            else messageBox.classList.add('bg-green-500');
            
            setTimeout(() => { messageBox.classList.add('hidden'); }, 3000);
        }

        // Convert Data URL to File object
        function dataURLtoFile(dataurl, filename) {
            var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){ u8arr[n] = bstr.charCodeAt(n); } 
            return new File([u8arr], filename, {type:mime});
        }
        
        // Parse content string into an object for Excel export
        function parseContentToObject(contentString) {
            const data = {
                '产品名称': '', '产品描述': '', '概要': '', '关键词': '',
            };
            if (!contentString) return data;

            const sections = contentString.split(/### (Title|Description|Summary|Keywords)\n---/g).filter(s => s && s.trim() !== '');

            for (let i = 0; i < sections.length; i += 2) {
                const englishTitle = sections[i].trim();
                const content = sections[i + 1] ? sections[i+1].trim() : '';
                const chineseTitle = ENGLISH_TITLE_MAP[englishTitle];
                if (chineseTitle) {
                    data[chineseTitle] = enforceContentLimits(chineseTitle, content);
                }
            }
            return data;
        }

        // Export history items to an Excel file
        function exportToExcel(items) {
            if (!items || items.length === 0) {
                showMessage('没有可导出的历史记录。', 'info');
                return;
            }

            const dataForSheet = items.map(item => {
                const parsedData = parseContentToObject(item.content);
                return {
                    '产品概念': item.product,
                    '产品名称': parsedData['产品名称'],
                    '产品描述': parsedData['产品描述'],
                    '概要': parsedData['概要'],
                    '关键词': parsedData['关键词'],
                };
            });

            const worksheet = XLSX.utils.json_to_sheet(dataForSheet);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'ASI Products');

            // Set column widths for better readability
            worksheet["!cols"] = [
                { wch: 30 }, { wch: 50 }, { wch: 80 }, { wch: 50 }, { wch: 80 },
            ];

            // Apply wrap text style to all cells for better readability
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            for (let R = range.s.r; R <= range.e.r; ++R) { 
                for(let C = range.s.c; C <= range.e.c; ++C) {
                    const cell_address = { c: C, r: R };
                    const cell_ref = XLSX.utils.encode_cell(cell_address);
                    if (worksheet[cell_ref] && worksheet[cell_ref].t === 's') { 
                        if (!worksheet[cell_ref].s) worksheet[cell_ref].s = {};
                        worksheet[cell_ref].s.alignment = { wrapText: true, vertical: 'top', horizontal: 'left' };
                    }
                }
            }

            XLSX.writeFile(workbook, `ASI_Export_${new Date().toISOString().slice(0,10)}.xlsx`);
            showMessage('导出成功！', 'success');
        }

        // Call Gemini API with retry logic
        async function callGeminiAPI(prompt, base64Data, mimeType) {
            const userApiKey = localStorage.getItem('geminiApiKey');
            if (!userApiKey) {
                throw new Error('API密钥未配置。');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${userApiKey}`;
            const userParts = [{ text: prompt }];
            if (base64Data && mimeType) {
                userParts.unshift({ inlineData: { mimeType: mimeType, data: base64Data } });
            }
            
            const payload = {
                contents: [{ role: "user", parts: userParts }],
                generationConfig: { temperature: 0.6, topP: 1.0, maxOutputTokens: 8192 }
            };

            const MAX_RETRIES = 3; // Maximum number of retries
            const BASE_DELAY_MS = 1000; // Base delay in milliseconds (1 second)

            for (let i = 0; i <= MAX_RETRIES; i++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) {
                        let errorBody = '无法读取错误详情';
                        try {
                            const errorJson = await response.json();
                            errorBody = errorJson?.error?.message || response.statusText;
                            
                            // Specific handling for API key invalidation
                            if(errorJson?.error?.status === 'INVALID_ARGUMENT' && errorJson?.error?.message.includes("API_KEY_INVALID") || errorBody.includes('API key expired')){
                                throw new Error('API密钥无效 (INVALID_ARGUMENT)。请检查您的密钥。');
                            }

                            // Retry logic for 5xx errors or specific overload messages
                            if (response.status >= 500 || errorBody.includes('The model is overloaded')) {
                                if (i < MAX_RETRIES) {
                                    const delay = BASE_DELAY_MS * Math.pow(2, i); // Exponential backoff
                                    console.warn(`API请求失败: ${response.status} ${errorBody}. 正在重试... (延迟 ${delay / 1000}秒)`);
                                    await new Promise(resolve => setTimeout(resolve, delay));
                                    continue; // Retry the request
                                }
                            }
                        } catch(e) {
                            if (e.message.includes('API密钥无效')) throw e; // Re-throw API key error immediately
                            try { errorBody = await response.text(); } catch(e2) { /* ignore */}
                        }
                        // If not a retryable error or max retries reached, throw the error
                        throw new Error(`API请求失败: ${response.status} ${errorBody}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    
                    if (candidate?.content?.parts?.[0]?.text) {
                         if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                            console.warn(`API response may be partial. Reason: ${candidate.finishReason}`);
                         }
                         return candidate.content.parts[0].text.trim();
                    }

                    if (candidate) {
                        const finishReason = candidate.finishReason || '未知';
                        switch (finishReason) {
                            case 'SAFETY':
                                throw new Error("内容可能违反了安全策略，请修改输入后重试。");
                            case 'MAX_TOKENS':
                                throw new Error("内容生成超出最大长度限制，请尝试简化输入或参考文案。");
                            case 'RECITATION':
                                throw new Error("内容因引用受版权保护的材料而被阻止。");
                            default:
                                throw new Error(`AI未能生成有效内容。原因: ${finishReason}`);
                        }
                    }
                    
                    throw new Error("AI未能生成有效内容，API未返回任何候选结果。");

                } catch (error) {
                    // If the error is an API key error, re-throw it immediately without retry
                    if (error.message.includes('API密钥无效')) {
                        throw error;
                    }
                    // For other errors, if max retries reached, re-throw
                    if (i === MAX_RETRIES) {
                        throw error;
                    }
                    // Otherwise, log and continue to the next retry (handled by the loop)
                    console.error(`尝试 ${i + 1}/${MAX_RETRIES + 1} 失败:`, error.message);
                }
            }
            // Should not be reached, but as a fallback
            throw new Error("API请求在多次重试后仍然失败。");
        }
    </script>
</body>
</html>
