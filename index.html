<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASIå¹³å°ä¸“ç”¨AIåŠ©æ‰‹ (å¯¼å‡ºæ ¼å¼æœ€ç»ˆä¿®å¤)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            background-color: #f8fafc;
        }
        .prose-custom {
            color: #334155;
            line-height: 1.7;
        }
        .prose-custom h3 {
            color: #1e293b;
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
         .prose-custom h4 {
            color: #1e293b;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .prose-custom .content-block {
            white-space: pre-line;
            word-wrap: break-word;
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            position: relative;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #4f46e5;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        .mini-loader-inline {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4f46e5;
            border-radius: 50%;
            display: inline-block;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .history-item {
            transition: background-color 0.2s;
        }
        .history-item:hover {
            background-color: #f1f5f9;
        }
        .validation-msg {
            font-size: 0.8rem;
            font-weight: 500;
        }
        .input-group-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        .action-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            line-height: 1rem;
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            cursor: pointer;
            border: none;
        }
        .action-btn:hover {
            background-color: #e0e7ff;
        }
        .action-btn:disabled {
            background-color: #e2e8f0;
            color: #94a3b8;
            cursor: not-allowed;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        .section-wrapper.locked {
            background-color: #f0f5ff;
            border-radius: 0.5rem;
            padding: 2px 8px;
            margin: -2px -8px;
        }
    </style>
</head>
<body class="bg-slate-100">
    <header class="text-center py-6 px-4">
        <h1 class="text-3xl md:text-4xl font-bold text-slate-900">ASIå¹³å°ä¸“ç”¨AIåŠ©æ‰‹</h1>
        <p class="mt-2 text-slate-600">ä¸Šä¼ /ç²˜è´´å›¾ç‰‡ã€è¾“å…¥ä¿¡æ¯ä¸å‚è€ƒæ–‡æ¡ˆï¼Œä¸€é”®ç”Ÿæˆã€‚</p>
    </header>

    <main class="lg:grid lg:grid-cols-2 lg:gap-8 p-4">
        <div class="lg:sticky lg:top-4 self-start">
             <div class="bg-white p-6 rounded-2xl shadow-lg relative flex flex-col h-[848px]">
                <div class="flex justify-between items-center pb-4 border-b mb-4 flex-shrink-0">
                    <h2 class="text-xl font-bold text-slate-800">äº§å“ä¿¡æ¯</h2>
                    <div class="flex items-center gap-3">
                         <button id="clearAllBtn" class="text-sm bg-slate-200 text-slate-600 py-2 px-3 rounded-lg hover:bg-slate-300 transition" title="æ¸…ç©ºæ‰€æœ‰è¾“å…¥å’Œç»“æœ">
                            æ¸…ç©ºå†…å®¹
                        </button>
                        <button id="generateAllBtn" class="text-sm bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">
                            ä¸€é”®ç”Ÿæˆ
                        </button>
                    </div>
                </div>
                 <div class="flex-grow overflow-y-auto custom-scrollbar pr-3 -mr-3">
                    <div class="mb-6">
                        <p class="input-group-title">1. ä¸Šä¼ äº§å“å›¾ç‰‡ (æ¨è)</p>
                        <div id="image-preview-container" class="hidden group relative w-48 h-48 mx-auto border-2 border-dashed rounded-lg flex items-center justify-center bg-slate-50">
                            <img id="image-preview" class="max-w-full max-h-full rounded-md">
                            <button id="remove-image-btn" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">&times;</button>
                        </div>
                         <div id="upload-box" class="mt-2">
                            <label for="imageUpload" class="w-full cursor-pointer bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-lg text-center transition block">
                                ç‚¹å‡»ä¸Šä¼ æˆ–ç›´æ¥ç²˜è´´å›¾ç‰‡
                            </label>
                            <input type="file" id="imageUpload" class="hidden" accept="image/png, image/jpeg, image/webp">
                        </div>
                    </div>

                    <div class="border-t pt-6">
                         <p class="input-group-title">2. è¾“å…¥äº§å“ä¿¡æ¯</p>
                        <div>
                            <label for="productIdea" class="block text-sm font-medium text-slate-700 mb-1">äº§å“åç§°/æ¦‚å¿µ</label>
                            <input type="text" id="productIdea" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="ä¾‹å¦‚ï¼šå¸¦Logoçš„æ—…è¡Œä¿æ¸©æ¯">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                            <div>
                                <label for="productMaterial" class="block text-sm font-medium text-slate-700 mb-1">äº§å“æè´¨</label>
                                <input type="text" id="productMaterial" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="ä¾‹å¦‚ï¼š304ä¸é”ˆé’¢, ç«¹ç›–">
                            </div>
                            <div>
                                <label for="productSpecs" class="block text-sm font-medium text-slate-700 mb-1">å°ºå¯¸/è§„æ ¼</label>
                                <input type="text" id="productSpecs" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="ä¾‹å¦‚ï¼š20oz (600ml), é«˜20cm">
                            </div>
                            <div class="md:col-span-2">
                                <label for="productScenarios" class="block text-sm font-medium text-slate-700 mb-1">æ ¸å¿ƒå–ç‚¹/ä½¿ç”¨åœºæ™¯</label>
                                <textarea id="productScenarios" rows="3" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="ä¾‹å¦‚ï¼šåŒå±‚çœŸç©ºï¼Œä¿å†·12å°æ—¶ä¿çƒ­6å°æ—¶ã€‚"></textarea>
                            </div>
                            <div class="md:col-span-2">
                                <label for="referenceText" class="block text-sm font-medium text-slate-700 mb-1">å‚è€ƒæ–‡æ¡ˆ (é€‰å¡«)</label>
                                <textarea id="referenceText" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="è¯·ç²˜è´´å‚è€ƒçš„æ ‡é¢˜ã€æè¿°æˆ–å–ç‚¹..."></textarea>
                            </div>
                             <div class="md:col-span-2">
                                <label for="referenceKeywords" class="block text-sm font-medium text-slate-700 mb-1">å‚è€ƒå…³é”®è¯ (æ¥è‡ªå–å®¶ç²¾çµç­‰, é€‰å¡«)</label>
                                <textarea id="referenceKeywords" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm" placeholder="è¯·ç²˜è´´å…³é”®è¯åˆ—è¡¨ï¼Œç”¨é€—å·æˆ–æ¢è¡Œåˆ†éš”..."></textarea>
                                <div class="mt-2">
                                     <button id="toggleCustomPromptBtn" class="text-sm font-medium text-indigo-600 hover:text-indigo-500 flex items-center gap-1">
                                        <span>è‡ªå®šä¹‰å…³é”®è¯è§„åˆ™</span>
                                        <svg id="customPromptArrow" class="w-4 h-4 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>
                                    </button>
                                </div>
                                <div id="customPromptContainer" class="mt-2 hidden">
                                     <textarea id="customKeywordPrompt" rows="4" class="w-full p-2 border border-slate-300 rounded-lg shadow-sm text-sm bg-indigo-50" placeholder="è¯·åœ¨æ­¤å¤„è¾“å…¥ä½ å¯¹å…³é”®è¯ç”Ÿæˆçš„ç‰¹æ®Šè¦æ±‚ã€‚ä¾‹å¦‚ï¼š&#10;1. ç»å¯¹ä¸è¦å‡ºç°ä»»ä½•å“ç‰Œè¯ï¼Œå°¤å…¶æ˜¯ [å“ç‰ŒA, å“ç‰ŒB]ã€‚&#10;2. å¤šç”Ÿæˆå’Œâ€˜å•†åŠ¡ç¤¼å“â€™ã€â€˜å±•ä¼šèµ å“â€™ç›¸å…³çš„è¯ã€‚"></textarea>
                                </div>
                             </div>
                        </div>
                    </div>
                </div>
             </div>
        </div>

        <div class="mt-8 lg:mt-0 flex flex-col h-[848px] gap-8">
            <div id="historySection" class="bg-white p-6 rounded-2xl shadow-lg flex-shrink-0">
                <div id="historyHeader" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-slate-800">å†å²è®°å½•</h2>
                    <div class="flex items-center gap-2">
                        <button id="exportAllBtn" class="text-sm bg-green-100 text-green-700 font-medium py-1 px-3 rounded-lg hover:bg-green-200 transition">æ‰¹é‡å¯¼å‡º</button>
                        <button id="clearHistoryBtn" class="text-sm bg-red-100 text-red-700 font-medium py-1 px-3 rounded-lg hover:bg-red-200 transition">æ¸…ç©ºå†å²</button>
                        <button id="toggleHistoryBtn" class="p-1 rounded-full hover:bg-slate-200 transition">
                            <svg id="history-arrow" class="w-5 h-5 text-slate-600 transition-transform transform -rotate-90" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor">
                              <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                            </svg>
                        </button>
                    </div>
                </div>
                <ul id="historyList" class="space-y-2 max-h-0 overflow-y-auto mt-0 transition-all duration-500 ease-in-out custom-scrollbar">
                </ul>
            </div>
            
            <div id="output" class="bg-white p-6 rounded-2xl shadow-lg flex-grow min-h-0 flex flex-col">
                 <div class="overflow-y-auto custom-scrollbar -mr-3 pr-3 h-full">
                    <div id="placeholder" class="text-center text-slate-500 flex flex-col items-center justify-center h-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-slate-400 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" /></svg>
                        <p>AIç”Ÿæˆçš„å†…å®¹å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...</p>
                    </div>
                    <div id="loader" class="loader hidden"></div>
                    <div id="result" class="prose-custom"></div>
                </div>
            </div>
        </div>
        
        <div id="messageBox" class="fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg hidden fade-in">
            <p id="messageText"></p>
        </div>

        <div id="apiKeyModal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center z-50 px-4">
            <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md m-4">
                <h2 class="text-2xl font-bold text-slate-800 mb-4">é…ç½® API å¯†é’¥</h2>
                <p id="apiKeyMessage" class="text-slate-600 mb-4">ä¸ºäº†ä½¿ç”¨AIåŠŸèƒ½ï¼Œè¯·è¾“å…¥æ‚¨çš„ Google Gemini API å¯†é’¥ã€‚å¯†é’¥å°†å®‰å…¨åœ°å­˜å‚¨åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­ã€‚</p>
                <div class="mb-6">
                    <label for="apiKeyInput" class="block text-sm font-medium text-slate-700 mb-2">Gemini API Key</label>
                    <input type="password" id="apiKeyInput" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="åœ¨æ­¤è¾“å…¥æ‚¨çš„å¯†é’¥">
                </div>
                <div class="text-xs text-slate-500 mb-8">
                    ä¸çŸ¥é“å¦‚ä½•è·å–ï¼Ÿ 
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="font-medium text-indigo-600 hover:text-indigo-500">
                        ç‚¹å‡»æ­¤å¤„å‰å¾€ Google AI Studio è·å–
                    </a>
                </div>
                <div class="mt-8 flex justify-end">
                    <button id="saveApiKeyBtn" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition">ä¿å­˜å¯†é’¥</button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // DOM Elements
        const generateAllBtn = document.getElementById('generateAllBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const outputDiv = document.getElementById('output');
        const placeholder = document.getElementById('placeholder');
        const loader = document.getElementById('loader');
        const resultDiv = document.getElementById('result');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const historyList = document.getElementById('historyList');
        const historyHeader = document.getElementById('historyHeader');
        const historyArrow = document.getElementById('history-arrow');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const exportAllBtn = document.getElementById('exportAllBtn');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageBtn = document.getElementById('remove-image-btn');
        const uploadBox = document.getElementById('upload-box');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyMessage = document.getElementById('apiKeyMessage');
        const toggleCustomPromptBtn = document.getElementById('toggleCustomPromptBtn');
        const customPromptContainer = document.getElementById('customPromptContainer');
        const customPromptArrow = document.getElementById('customPromptArrow');
        const customKeywordPrompt = document.getElementById('customKeywordPrompt');
        const productSpecsInput = document.getElementById('productSpecs'); 
        
        let history = [];
        let uploadedImageBase64 = null;
        let uploadedImageType = null;

        // Mapping for regeneration types to Chinese titles
        const REGEN_TYPE_MAP = { 
            'title': 'äº§å“åç§°', 
            'description': 'äº§å“æè¿°', 
            'summary': 'æ¦‚è¦', 
            'keywords': 'å…³é”®è¯' 
        };
        
        // Mapping for English titles to Chinese titles
        const ENGLISH_TITLE_MAP = {
            'Title': 'äº§å“åç§°',
            'Description': 'äº§å“æè¿°',
            'Summary': 'æ¦‚è¦',
            'Keywords': 'å…³é”®è¯'
        };

        // Reverse mapping for Chinese titles to English titles
        const REVERSE_ENGLISH_TITLE_MAP = Object.fromEntries(Object.entries(ENGLISH_TITLE_MAP).map(a => a.reverse()));


        // Event Listeners
        document.addEventListener('DOMContentLoaded', initApp); // Initialize app on DOM load
        generateAllBtn.addEventListener('click', () => handleGeneration('all')); // Generate all content
        clearAllBtn.addEventListener('click', clearAllInputs); // Clear all input fields
        clearHistoryBtn.addEventListener('click', clearHistory); // Clear history
        exportAllBtn.addEventListener('click', () => exportToExcel(history)); // Export history to Excel
        historyHeader.addEventListener('click', (e) => { // Toggle history visibility
            if (!e.target.closest('#clearHistoryBtn') && !e.target.closest('#exportAllBtn')) {
                toggleHistory();
            }
        });
        historyList.addEventListener('click', handleHistoryListClick); // Handle clicks on history items
        imageUpload.addEventListener('change', handleImageFile); // Handle image file upload
        removeImageBtn.addEventListener('click', removeImage); // Remove uploaded image
        document.addEventListener('paste', handlePaste); // Handle image paste from clipboard
        resultDiv.addEventListener('click', handleResultClick); // Handle clicks on generated result section
        saveApiKeyBtn.addEventListener('click', saveApiKey); // Save API key
        toggleCustomPromptBtn.addEventListener('click', toggleCustomPrompt); // Toggle custom keyword prompt visibility
        customKeywordPrompt.addEventListener('input', saveCustomPrompt); // Save custom prompt on input
        productSpecsInput.addEventListener('input', handleProductSpecsInput); // Handle product specs input (for potential future enhancements)


        // Initialize the application
        function initApp() {
            loadHistory(); // Load saved history
            const savedKey = localStorage.getItem('geminiApiKey');
            if (!savedKey) {
                showApiKeyModal('æ¬¢è¿ä½¿ç”¨ï¼è¯·å…ˆé…ç½®æ‚¨çš„APIå¯†é’¥ã€‚'); // Prompt for API key if not found
            }
            loadCustomPrompt(); // Load custom keyword prompt
        }
        
        // Load custom keyword prompt from local storage
        function loadCustomPrompt() {
            const savedPrompt = localStorage.getItem('customKeywordPrompt');
            if (savedPrompt) {
                customKeywordPrompt.value = savedPrompt;
            }
        }

        // Save custom keyword prompt to local storage
        function saveCustomPrompt() {
            localStorage.setItem('customKeywordPrompt', customKeywordPrompt.value);
        }

        // Toggle visibility of custom keyword prompt
        function toggleCustomPrompt() {
            customPromptContainer.classList.toggle('hidden');
            customPromptArrow.classList.toggle('rotate-180');
        }

        // Display API key modal with a given message
        function showApiKeyModal(message) {
            apiKeyMessage.textContent = message || 'ä¸ºäº†ä½¿ç”¨AIåŠŸèƒ½ï¼Œè¯·è¾“å…¥æ‚¨çš„ Google Gemini API å¯†é’¥ã€‚å¯†é’¥å°†ä»…å­˜å‚¨åœ¨æ‚¨çš„æµè§ˆå™¨æœ¬åœ°ã€‚';
            apiKeyModal.classList.remove('hidden');
            // Ensure the modal is visible and on top
            apiKeyModal.style.display = 'flex';
            apiKeyInput.focus(); // Focus on the input field
        }

        // Save API key to local storage
        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                apiKeyModal.style.display = 'none'; // Hide modal
                showMessage('APIå¯†é’¥å·²ä¿å­˜ï¼', 'success');
            } else {
                showMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„APIå¯†é’¥ã€‚', 'error');
            }
        }

        // Handle image file selection
        function handleImageFile(event) {
            const file = event.target.files[0];
            if (file) processImageFile(file);
        }
        
        // Handle image paste from clipboard
        function handlePaste(event) {
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    event.preventDefault(); // Prevent default paste behavior
                    processImageFile(item.getAsFile());
                    break; 
                }
            }
        }

        // Process the image file (read as Data URL and display preview)
        function processImageFile(file) {
             if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedImageBase64 = e.target.result.split(',')[1]; // Get base64 data
                uploadedImageType = file.type; // Get image type
                imagePreview.src = e.target.result; // Set image preview source
                imagePreviewContainer.classList.remove('hidden'); // Show preview container
                uploadBox.classList.add('hidden'); // Hide upload box
            };
            reader.readAsDataURL(file); // Read file as Data URL
        }

        // Remove the uploaded image
        function removeImage() {
            uploadedImageBase64 = null;
            uploadedImageType = null;
            imagePreview.src = '';
            imageUpload.value = ''; // Clear file input
            imagePreviewContainer.classList.add('hidden'); // Hide preview container
            uploadBox.classList.remove('hidden'); // Show upload box
        }
        
        // Clear all input fields and results
        function clearAllInputs() {
            removeImage(); // Remove image
            document.getElementById('productIdea').value = '';
            document.getElementById('productMaterial').value = '';
            document.getElementById('productSpecs').value = '';
            document.getElementById('productScenarios').value = '';
            document.getElementById('referenceText').value = '';
            document.getElementById('referenceKeywords').value = '';
            resultDiv.innerHTML = ''; // Clear result display
            placeholder.classList.remove('hidden'); // Show placeholder
            generateAllBtn.innerHTML = 'ä¸€é”®ç”Ÿæˆ'; // Reset generate button text
            showMessage('æ‰€æœ‰å†…å®¹å·²æ¸…ç©ºã€‚', 'success');
        }
        
        // Handle clicks within the result display area (regenerate, copy, translate, lock)
        function handleResultClick(event) {
            const regenBtn = event.target.closest('.regenerate-btn');
            const copyBtn = event.target.closest('.copy-btn');
            const translateBtn = event.target.closest('.translate-btn');
            const lockBtn = event.target.closest('.lock-btn');

             if (regenBtn) {
                const type = regenBtn.dataset.type;
                handleSingleRegeneration(type); // Regenerate a single section
            } else if (copyBtn) {
                const contentBlock = copyBtn.closest('.section-wrapper').querySelector('.content-block');
                const textToCopy = getCleanTextFromBlock(contentBlock);
                copyToClipboard(textToCopy); // Copy content to clipboard
            } else if (translateBtn) {
                const contentBlock = translateBtn.closest('.section-wrapper').querySelector('.content-block');
                const textToTranslate = getCleanTextFromBlock(contentBlock);
                openGoogleTranslate(textToTranslate); // Open content in Google Translate
            } else if (lockBtn) {
                toggleLock(lockBtn); // Toggle section lock state
            }
        }
        
        // Extract clean text from a content block, handling <br> tags
        function getCleanTextFromBlock(contentBlock) {
            if (!contentBlock) return '';
            const clone = contentBlock.cloneNode(true);

            // Remove the counter div before extracting text
            const counter = clone.querySelector('.absolute.bottom-2.right-2');
            if (counter) {
                counter.remove();
            }

            let textContent = '';
            // Iterate through child nodes to explicitly handle <br> tags
            clone.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    // For text nodes, append their content
                    textContent += node.textContent;
                } else if (node.tagName === 'BR') {
                    // For <br> tags, append a newline character
                    textContent += '\n';
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // For other element nodes (e.g., nested spans, though unlikely in content-block),
                    // recursively get their innerText.
                    textContent += node.innerText; 
                }
            });

            return textContent.trim();
        }

        // Toggle the lock state of a content section
        function toggleLock(lockBtn) {
            const section = lockBtn.closest('.section-wrapper');
            const isLocked = section.classList.toggle('locked');
            const regenBtn = section.querySelector('.regenerate-btn');
            
            // Update lock button icon and text
            lockBtn.innerHTML = isLocked ? 
                `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg><span>é”å®š</span>` :
                `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 = 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2"/></svg><span>è§£é”</span>`;
            
            lockBtn.setAttribute('title', isLocked ? 'ç‚¹å‡»è§£é”' : 'ç‚¹å‡»é”å®š');
            if (regenBtn) {
                regenBtn.disabled = isLocked; // Disable regenerate button if locked
            }
        }

        // Open content in Google Translate
        function openGoogleTranslate(text) {
            const encodedText = encodeURIComponent(text);
            const url = `https://translate.google.com/?sl=en&tl=zh-CN&text=${encodedText}&op=translate`;
            window.open(url, '_blank');
        }

        // Copy text to clipboard
        function copyToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
            } catch (err) {
                showMessage('å¤åˆ¶å¤±è´¥ï¼', 'error');
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textArea);
        }
        
        // Extract clean content by removing markdown headers
        function extractCleanContent(rawText) {
             if (!rawText) return '';
             return rawText.replace(/^###\s+(Title|Summary|Description|Keywords)\s*\n---\n?/, '').trim();
        }

        // Handle overall content generation (all sections or unlocked sections)
        async function handleGeneration(type) {
            const productIdea = document.getElementById('productIdea').value.trim();
            if (!productIdea) {
                showMessage('è¯·è¾“å…¥äº§å“åç§°/æ¦‚å¿µã€‚', 'error');
                return;
            }

            const sections = Array.from(resultDiv.querySelectorAll('.section-wrapper'));
            const lockedContent = new Map();
            const unlockedTypes = new Set(['title', 'description', 'summary', 'keywords']);

            // Identify locked sections and their content
            sections.forEach(section => {
                if (section.classList.contains('locked')) {
                    const type = section.querySelector('.regenerate-btn')?.dataset.type;
                    if (type) {
                        lockedContent.set(type, section.innerHTML);
                        unlockedTypes.delete(type);
                    }
                }
            });

            // If all sections are locked, no generation is needed
            if (unlockedTypes.size === 0 && sections.length > 0) {
                showMessage('æ‰€æœ‰æ¨¡å—éƒ½å·²é”å®šï¼Œæ— éœ€ç”Ÿæˆã€‚', 'info');
                return;
            }

            const typesToGenerate = Array.from(unlockedTypes);
            if (typesToGenerate.length === 0) {
                typesToGenerate.push('all'); // If no unlocked types, generate all (first run or all were locked then unlocked)
            }

            // Gather product details from input fields
            const material = document.getElementById('productMaterial').value.trim();
            let specs = document.getElementById('productSpecs').value.trim(); // Get raw specs
            const scenarios = document.getElementById('productScenarios').value.trim();
            const referenceText = document.getElementById('referenceText').value.trim();
            const referenceKeywords = document.getElementById('referenceKeywords').value.trim();
            const customKeywordText = customKeywordPrompt.value.trim();

            // Convert cm to inches for prompt if 'cm' is present in specs
            const cmToInchConversion = convertCmToInches(specs);
            if (cmToInchConversion) {
                specs = cmToInchConversion; // Use the formatted string for the prompt
            }

            const details = { material, specs, scenarios, referenceText, referenceKeywords, customKeywordPrompt: customKeywordText };
            
            // Determine generation mode based on number of types to generate
            const generationMode = typesToGenerate.length >= 4 ? 'all' : typesToGenerate.join(',');
            const prompt = createPrompt(generationMode, productIdea, details);

            showLoading(true); // Show loading indicator
            try {
                const text = await callGeminiAPI(prompt, uploadedImageBase64, uploadedImageType);
                
                // Merge new results with locked content
                if (lockedContent.size > 0) {
                    const newResultHtml = parseAndMergeResults(text, lockedContent, productIdea);
                    resultDiv.innerHTML = newResultHtml;
                } else {
                    displayResult(text, 'all', productIdea); // Display all new results
                }
                
                // Save the full content to history
                const fullContentForHistory = resultDiv.innerHTML;
                const fullTextContent = convertHtmlToStructuredText(fullContentForHistory);
                await saveToHistory(productIdea, fullTextContent, details, uploadedImageBase64, uploadedImageType);
                
                generateAllBtn.innerHTML = 'ğŸš€ é‡æ–°ç”Ÿæˆ'; // Update button text

            } catch (error) {
                console.error('API Call Error:', error);
                const errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
                displayResult(`æŠ±æ­‰ï¼Œè°ƒç”¨AIæœåŠ¡æ—¶å‡ºé”™ï¼š${errorMessage}`, 'error'); // Display error message
                showMessage(`AIæœåŠ¡è°ƒç”¨å¤±è´¥: ${errorMessage}`, 'error');

                // If API key is invalid, show modal
                if (errorMessage.includes('401') || errorMessage.includes('APIå¯†é’¥') || errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key expired')) {
                    showApiKeyModal('APIå¯†é’¥æ— æ•ˆæˆ–ç¼ºå¤±ï¼Œè¯·æ›´æ–°æˆ–æ·»åŠ å¯†é’¥ã€‚');
                }

            } finally {
                showLoading(false); // Hide loading indicator
            }
        }
        
        // Handle regeneration of a single content section
        async function handleSingleRegeneration(type) {
            const productIdea = document.getElementById('productIdea').value.trim();
            if (!productIdea) {
                showMessage('æ— æ³•åœ¨æ²¡æœ‰äº§å“æ¦‚å¿µçš„æƒ…å†µä¸‹é‡æ–°ç”Ÿæˆã€‚', 'error');
                return;
            }

            // Gather product details (same as handleGeneration)
            const material = document.getElementById('productMaterial').value.trim();
            let specs = document.getElementById('productSpecs').value.trim();
            const scenarios = document.getElementById('productScenarios').value.trim();
            const referenceText = document.getElementById('referenceText').value.trim();
            const referenceKeywords = document.getElementById('referenceKeywords').value.trim();
            const customKeywordText = customKeywordPrompt.value.trim();

            const cmToInchConversion = convertCmToInches(specs);
            if (cmToInchConversion) {
                specs = cmToInchConversion;
            }

            const details = { material, specs, scenarios, referenceText, referenceKeywords, customKeywordText: customKeywordText };

            const sectionTitle = REGEN_TYPE_MAP[type];
            const sectionWrapper = document.getElementById(`section-${sectionTitle.replace(/\s/g, '-')}`);
            if (!sectionWrapper) return;

            const regenerateButton = sectionWrapper.querySelector('.regenerate-btn');
            
            // Show mini loader and disable button during regeneration
            if (regenerateButton) {
                regenerateButton.innerHTML = `<span class="mini-loader-inline"></span>`;
                regenerateButton.disabled = true;
            }

            const prompt = createPrompt(type, productIdea, details);

            try {
                const rawText = await callGeminiAPI(prompt, uploadedImageBase64, uploadedImageType);
                let newCleanText = extractCleanContent(rawText);

                newCleanText = enforceContentLimits(sectionTitle, newCleanText); // Enforce content limits

                const contentBlock = sectionWrapper.querySelector('.content-block');
                contentBlock.innerText = newCleanText; // Update content
                
                const counterDiv = createCounterDiv(sectionTitle, newCleanText); // Update counter
                if (counterDiv) contentBlock.appendChild(counterDiv);

                const validationResult = validateContent(sectionTitle, newCleanText); // Validate content
                const statusSpan = sectionWrapper.querySelector('.validation-status');
                if(statusSpan) {
                     statusSpan.innerHTML = getValidationStatus(validationResult); // Update validation status
                }
                
                await updateHistoryContent(productIdea, sectionTitle, newCleanText); // Update history
            } catch (error) {
                 const errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
                 showMessage(`é‡æ–°ç”Ÿæˆ'${sectionTitle}'å¤±è´¥: ${errorMessage}`, 'error');
                 if (errorMessage.includes('401') || errorMessage.includes('APIå¯†é’¥') || errorMessage.includes('API_KEY_INVALID') || errorMessage.includes('API key expired')) {
                    showApiKeyModal('APIå¯†é’¥æ— æ•ˆæˆ–ç¼ºå¤±ï¼Œè¯·æ›´æ–°æˆ–æ·»åŠ å¯†é’¥ã€‚');
                 }
            } finally {
                 // Restore regenerate button state
                 if (regenerateButton) {
                    regenerateButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg><span>é‡æ–°ç”Ÿæˆ</span>`;
                    regenerateButton.disabled = false;
                }
            }
        }

        /**
         * Converts centimeters to inches within a given string.
         * Looks for patterns like "10cm", "20 cm", "30.5cm", etc.
         * @param {string} specsString The input string containing specifications.
         * @returns {string} The updated string with cm values converted to inches and appended, or original string if no cm found.
         */
        function convertCmToInches(specsString) {
            if (!specsString) return '';
            let convertedString = specsString;
            // Regex to find numbers followed by 'cm' or ' cm'
            const cmRegex = /(\d+(\.\d+)?)\s*cm/gi; 
            let match;
            let replacements = [];

            // Find all matches and store them
            while ((match = cmRegex.exec(specsString)) !== null) {
                const cmValue = parseFloat(match[1]);
                if (!isNaN(cmValue)) {
                    const inchValue = (cmValue / 2.54).toFixed(2); // Convert to inches, 2 decimal places
                    replacements.push({
                        original: match[0],
                        replacement: `${match[0]} (approx ${inchValue} inches)`
                    });
                }
            }

            // Apply replacements from back to front to avoid index issues
            for (let i = replacements.length - 1; i >= 0; i--) {
                const rep = replacements[i];
                // Use a global regex to replace all occurrences, but only the specific matched string
                convertedString = convertedString.split(rep.original).join(rep.replacement);
            }

            return convertedString;
        }

        // This function is currently not modifying the input field directly,
        // as the request was to include it in the *description* generated by AI.
        // If direct input field modification is desired, this is where it would go.
        function handleProductSpecsInput() {
            // No direct modification of input field here.
        }

        // Create the prompt string for the Gemini API call
        function createPrompt(type, product, details) {
            let productDetailsSection = "\n**Product Details (Use these text details to supplement the provided image):**";
            let hasDetails = false;
            if (details.material) { productDetailsSection += `\n- Material: ${details.material}`; hasDetails = true; }
            // Use the potentially converted specs for the prompt
            if (details.specs) { productDetailsSection += `\n- Specifications: ${details.specs}`; hasDetails = true; } 
            if (details.scenarios) { productDetailsSection += `\n- Key Selling Points/Scenarios: ${details.scenarios}`; hasDetails = true; }
            if (details.referenceText) {
                productDetailsSection += `\n- **Reference Text (Crucial):** """${details.referenceText}"""`;
                hasDetails = true;
            }
             if (details.referenceKeywords) {
                productDetailsSection += `\n- **Reference Keywords (High Priority):** """${details.referenceKeywords}"""`;
                hasDetails = true;
            }

            const basePrompt = `You are an expert copywriter for the B2B promotional products platform ASI. Your primary role is to act as a market researcher and content generator.\n\n**Step 1: Simulated Web Research.**\nBased on the user's 'Product Concept', you must first perform a simulated web search on popular e-commerce sites (like Amazon.com) and promotional product platforms (like ASI, 4imprint) to gather typical features, materials, specifications, and marketing angles for this type of product. You must use this simulated research as the primary context for your writing, especially if the user has not provided detailed reference text. For example, if the user enters "umbrella", you should imagine searching for "promotional travel umbrella" and "custom logo umbrella" and use the common features you find (e.g., auto-open, fiberglass ribs, SPF 50+ canopy) to enrich your output.\n\n**Step 2: Content Generation.**\nUsing the context from your research AND the specific details provided by the user, generate the required content. User-provided details (like material, specs, reference text) ALWAYS take precedence over your general research.\n\n**User's Input:**\n- Product Concept: ${product}${hasDetails ? productDetailsSection : ''}\n\n**CRUCIAL, UNBREAKABLE RULES:**\n- **ALL OUTPUT MUST BE IN ENGLISH.** Do not include any Chinese characters or any other language in the output.\n- **YOUR RESPONSE MUST START DIRECTLY WITH '### Title'.** Any other starting text, preamble, or conversational filler will cause a system crash.`;
            
            const titleRules = `**Title Rules:**\n1. Generate 5 unique product names. Each on a new line.\n2. Each name MUST be Title Case (first letter of each word capitalized).\n3. Each name MUST be under 60 characters.\n4. A name MUST NOT contain any repeated words.`;
            const summaryRules = `**Summary Rules:**\n1. Generate one concise paragraph summarizing the product's key highlights.\n2. The summary MUST be a complete, grammatically correct sentence. Prioritize sentence completeness over hitting the exact 130-character limit. It should be under 130 characters.`; // Modified rule
            const descriptionRules = `**Description Rules:**\n1. The description MUST be under 800 characters.\n2. It MUST NOT contain any Chinese punctuation. Use only standard English punctuation.\n3. It MUST NOT contain any price-related language (e.g., "$", "price", "cost").\n4. Structure the paragraph around: Material, Function, Usage Scenarios, Advantages, and an assurance statement.`;
            
            let keywordRules = `**Keywords Rules:**
**ABSOLUTE PRIMARY RULES (THIS IS A NON-NEGOTIABLE FINAL CHECK):**
1. **The final output MUST contain EXACTLY 30 keyword groups.** Not 29, not 31. Exactly 30.
2. **Each of the 30 groups MUST be under 30 characters.** This is a strict platform limit.

**Formatting and Content Rules:**
3. Each group MUST be separated by a comma and a space (e.g., "Word One, Word Two").
4. Each group MUST be Title Case.
5. Each group MUST be a short phrase, ideally 2-3 words. Do not write full sentences.
6. Use relevant terms a customer would search for. DO NOT use irrelevant words.
7. DO NOT repeat phrases already used in the Title, Summary, or Description.
8. DO NOT stuff or repeat keywords.
9. DO NOT use plurals, symbols, or abbreviations.
10. DO NOT use subjective praise (e.g., "Best", "Amazing").
11. **Crucially, use the "Reference Keywords" as the primary source.** Clean them up to meet all rules above. If the cleaned reference list is not enough, generate more relevant, non-brand keywords to reach exactly 30 groups. Actively identify and exclude any potential brand names or trademarks.`;
            
            if (details.customKeywordPrompt) {
                keywordRules += `\n\n**--- CRITICAL USER-DEFINED RULES OVERRIDE ---\nTHE FOLLOWING INSTRUCTIONS OVERRIDE ANY PREVIOUS RULES FOR KEYWORDS. YOU MUST FOLLOW THEM PRECISELY, WHILE STILL RESPECTING THE ABSOLUTE PRIMARY RULES ABOVE:**\n"""\n${details.customKeywordPrompt}\n"""`;
            }

            const typeRulesMap = { 'title': titleRules, 'description': descriptionRules, 'summary': summaryRules, 'keywords': keywordRules };
            const englishHeaders = { 'title': 'Title', 'description': 'Description', 'summary': 'Summary', 'keywords': 'Keywords'};

            let taskDescription = '';
            let rulesDescription = '';
            const typesToGenerate = type.split(',').filter(t => t && t !== 'all');

            if (type === 'all' || typesToGenerate.length >= 4) {
                 taskDescription = `**Task: Generate all content sections: Title, Description, Summary, and Keywords.**`;
                 rulesDescription = `**Output Structure & Rules:**\nFollow this structure precisely. Do not add any text before "### Title".\n\n### Title\n---\n[5 names, each on a new line]\n\n### Description\n---\n[1 paragraph]\n\n### Summary\n---\n[1 paragraph]\n\n### Keywords\n---\n[30 comma-separated groups]\n\n${titleRules}\n${descriptionRules}\n${summaryRules}\n${keywordRules}`;
            } else {
                taskDescription = `**Task: Generate ONLY the following sections: ${typesToGenerate.map(t => englishHeaders[t]).join(', ')}.**`;
                rulesDescription = `**Output Structure & Rules:**\n` + typesToGenerate.map(t => `### ${englishHeaders[t]}\n---\n[Content for ${englishHeaders[t]}]\n\n${typeRulesMap[t]}`).join('\n\n');
            }

            return `${basePrompt}\n\n${taskDescription}\n\n${rulesDescription}`;
        }
        
        // Enforce content length and format limits based on content type
        function enforceContentLimits(chineseTitle, text) {
            let enforcedText = text;
            switch (chineseTitle) {
                case 'æ¦‚è¦':
                    // If the text is longer than 130 characters, try to truncate at the last full stop or word boundary.
                    if (enforcedText.length > 130) {
                        let truncated = enforcedText.substring(0, 130);
                        let lastFullStop = truncated.lastIndexOf('.');
                        let lastSpace = truncated.lastIndexOf(' ');

                        if (lastFullStop !== -1 && lastFullStop > truncated.length - 20) { // If a full stop is near the end
                            enforcedText = truncated.substring(0, lastFullStop + 1);
                        } else if (lastSpace !== -1 && lastSpace > truncated.length - 20) { // If a space is near the end
                            enforcedText = truncated.substring(0, lastSpace);
                        } else {
                            // Fallback to simple truncation if no good boundary is found near the limit
                            enforcedText = truncated;
                        }
                    }
                    break;
                case 'å…³é”®è¯':
                    let keywords = enforcedText.split(',').map(k => k.trim()).filter(Boolean);
                    if (keywords.length > 30) {
                        keywords = keywords.slice(0, 30);
                    }
                    keywords = keywords.map(kw => {
                        if (kw.length > 30) {
                            let truncatedKw = kw.substring(0, 30);
                            return truncatedKw.substring(0, Math.min(truncatedKw.length, truncatedKw.lastIndexOf(' ')) || truncatedKw.length);
                        }
                        return kw;
                    });
                    enforcedText = keywords.join(', ');
                    break;
            }
            return enforcedText;
        }

        // Validate content against defined rules
        function validateContent(chineseTitle, text) {
            const results = { isValid: true, messages: [] };
             if (/[ä¸€-é¾ ]/.test(text)) { // Check for Chinese characters
                results.isValid = false; 
                results.messages.push(`åŒ…å«ä¸­æ–‡`); 
            }
            switch (chineseTitle) {
                case 'äº§å“åç§°':
                    // No specific validation rules beyond general Chinese character check
                    break;
                case 'æ¦‚è¦':
                     // Changed validation to check for a full stop at the end for sentence completeness
                    if (text.length > 130) { 
                        results.isValid = false; 
                        results.messages.push(`æ¦‚è¦è¶…é•¿ (${text.length}/130)`); 
                    }
                    if (!text.endsWith('.') && text.length > 0) { // Check for full stop at the end if not empty
                        results.isValid = false;
                        results.messages.push(`éå®Œæ•´å¥å­`);
                    }
                    break;
                case 'äº§å“æè¿°':
                    if (text.length > 800) { results.isValid = false; results.messages.push(`æè¿°è¶…é•¿ (${text.length}/800)`); }
                    if (/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š]/.test(text)) { results.isValid = false; results.messages.push(`å«ä¸­æ–‡æ ‡ç‚¹`); } // Check for Chinese punctuation
                    break;
                case 'å…³é”®è¯':
                    const keywords = text.split(',').map(k => k.trim()).filter(Boolean);
                    if (keywords.length !== 30) { results.isValid = false; results.messages.push(`ç»„æ•°: ${keywords.length} (åº”ä¸º30)`); }
                    
                    const longKeywords = keywords.filter(kw => kw.length > 30);
                    if (longKeywords.length > 0) {
                        results.isValid = false;
                        results.messages.push(`å…³é”®è¯è¶…é•¿ (${longKeywords[0].length}/30)`);
                    }
                    break;
            }
            return results;
        }
        
        // Get validation status HTML string
        function getValidationStatus(validationResult) {
            if (!validationResult.isValid) {
                const message = validationResult.messages.join(', ');
                return `<span class="validation-msg text-red-500">(âš ï¸ ${message})</span>`;
            }
            return '<span class="text-green-500">âœ…</span>';
        }

        // Create a counter div for content length/count
        function createCounterDiv(chineseTitle, content) {
            let countHtml = '';
             switch (chineseTitle) {
                case 'æ¦‚è¦':
                    countHtml = `${content.length} / 130`;
                    break;
                case 'äº§å“æè¿°':
                    countHtml = `${content.length} / 800`;
                    break;
                case 'å…³é”®è¯':
                    const keywordCount = content.split(',').filter(Boolean).length;
                    countHtml = `${keywordCount} / 30 ç»„`;
                    break;
            }

            if (countHtml) {
                const countDiv = document.createElement('div');
                countDiv.className = 'absolute bottom-2 right-2 text-xs text-slate-400';
                countDiv.textContent = countHtml;
                return countDiv;
            }
            return null;
        }

        // Toggle history list visibility
        function toggleHistory() {
            historyList.classList.toggle('max-h-0');
            historyList.classList.toggle('mt-0');
            historyList.classList.toggle('max-h-96');
            historyList.classList.toggle('mt-4');
            historyArrow.classList.toggle('rotate-180');
        }
        
        // Compress image for history storage (thumbnail)
        async function compressImage(src, maxWidth = 200, maxHeight = 200, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                    } else {
                        if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    const dataUrl = canvas.toDataURL('image/jpeg', quality);
                    const [header, base64Data] = dataUrl.split(',');
                    resolve({ base64: base64Data, type: 'image/jpeg' });
                };
                img.onerror = (error) => reject(error);
            });
        }
        
        // Load history from local storage
        function loadHistory() {
            try {
                const storedHistory = localStorage.getItem('asiProductHistory');
                if (storedHistory) { history = JSON.parse(storedHistory); renderHistory(); }
            } catch (e) { console.error("Failed to load history:", e); localStorage.removeItem('asiProductHistory'); }
        }

        // Render history list items
        function renderHistory() {
            historyList.innerHTML = '';
            if(history.length === 0){
                historyList.innerHTML = `<li class="text-slate-400 text-center text-sm p-4">æš‚æ— å†å²è®°å½•</li>`;
                return;
            }
            history.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'history-item flex justify-between items-center p-3 rounded-lg border border-slate-200';
                li.dataset.index = index;
                li.innerHTML = `
                    <span class="truncate cursor-pointer flex-grow history-item-view" title="${item.product}">${item.product}</span>
                    <button class="history-item-export ml-4 text-xs bg-blue-100 text-blue-700 font-medium py-1 px-2 rounded-md hover:bg-blue-200 transition-colors flex-shrink-0" data-index="${index}">å¯¼å‡º</button>
                `;
                historyList.appendChild(li);
            });
        }

        // Handle clicks on history list (view or export)
        function handleHistoryListClick(event) {
            const target = event.target;
            const viewTarget = target.closest('.history-item-view');
            const exportTarget = target.closest('.history-item-export');

            if (exportTarget) {
                const index = exportTarget.dataset.index;
                const itemToExport = history[index];
                if (itemToExport) {
                    exportToExcel([itemToExport]);
                }
            } else if (viewTarget) {
                 const li = viewTarget.closest('.history-item');
                 const index = li.dataset.index;
                 viewHistoryItem(index);
            }
        }
        
        // Save current generation to history
        async function saveToHistory(product, content, details, fullResImageBase64, fullResImageType) {
            const existingIndex = history.findIndex(item => item.product === product);
            if (existingIndex > -1) history.splice(existingIndex, 1); // Remove existing entry if product name matches
            
            let thumbnailImage = { base64: null, type: null };
            if (fullResImageBase64 && fullResImageType) {
                const dataUrl = `data:${fullResImageType};base64,${fullResImageBase64}`;
                try {
                    thumbnailImage = await compressImage(dataUrl, 200, 200, 0.7); // Compress image for thumbnail
                } catch (e) {
                    console.error("Image compression for history failed:", e);
                    thumbnailImage = { base64: null, type: null };
                }
            }

            history.unshift({ // Add to the beginning of history
                product,
                content,
                details,
                imageBase64: thumbnailImage.base64,
                imageType: thumbnailImage.type
            });

            try {
                if (history.length > 50) history.pop(); // Keep history limited to 50 items
                localStorage.setItem('asiProductHistory', JSON.stringify(history)); // Save to local storage
            } catch (e) {
                showMessage('å†å²è®°å½•å­˜å‚¨å¤±è´¥ï¼Œå¯èƒ½å·²æ»¡ã€‚', 'error');
                console.error("Failed to save history to localStorage:", e);
                history.shift(); // Remove the added item if storage fails
            }
            renderHistory(); // Re-render history list
        }

        // Update content of an existing history item
        async function updateHistoryContent(product, chineseTitle, newContent) {
             const existingIndex = history.findIndex(item => item.product === product);
            if (existingIndex > -1) {
                const currentItem = history[existingIndex];
                const englishTitle = REVERSE_ENGLISH_TITLE_MAP[chineseTitle];
                if (!englishTitle) return;

                // Use regex to find and replace the specific section content
                const regex = new RegExp(`(### ${englishTitle}\\n---)([\\s\\S]*?)(?=\\n###|$)`);
                const updatedContent = currentItem.content.replace(regex, `$1\n${newContent.trim()}\n`);
                history[existingIndex].content = updatedContent;
                try {
                    localStorage.setItem('asiProductHistory', JSON.stringify(history));
                } catch (e) {
                     console.error("Failed to update history in localStorage:", e);
                }
            }
        }

        // View a history item (load its content into the main input/output areas)
        function viewHistoryItem(index) {
            const item = history[index];
            if (item) {
                clearAllInputs(); // Clear current inputs

                // Populate input fields
                document.getElementById('productIdea').value = item.product || '';
                if(item.details){
                    document.getElementById('productMaterial').value = item.details.material || '';
                    document.getElementById('productSpecs').value = item.details.specs || '';
                    document.getElementById('productScenarios').value = item.details.scenarios || '';
                    document.getElementById('referenceText').value = item.details.referenceText || '';
                    document.getElementById('referenceKeywords').value = item.details.referenceKeywords || '';
                }

                const imageB64 = item.originalImageBase64 || item.imageBase64; // Use original if available, else thumbnail
                const imageT = item.originalImageType || item.imageType;
                
                if (imageB64 && imageT) {
                    const dataUrl = `data:${imageT};base64,${imageB64}`;
                    processImageFile(dataURLtoFile(dataUrl, item.product)); // Load image
                }
                
                displayResult(item.content, 'all', item.product); // Display generated content
                generateAllBtn.innerHTML = 'ğŸš€ é‡æ–°ç”Ÿæˆ'; // Update button text
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top
            }
        }

        // Clear all history
        function clearHistory() {
            history = [];
            localStorage.removeItem('asiProductHistory');
            renderHistory();
            showMessage('å†å²è®°å½•å·²æ¸…ç©ºã€‚', 'success');
        }
        
        // Show/hide loading indicator
        function showLoading(isLoading) {
            loader.classList.toggle('hidden', !isLoading);
            if (isLoading) { placeholder.classList.add('hidden'); resultDiv.innerHTML = ''; }
        }
        
        // Build HTML for a single content section
        function buildSectionHtml(chineseTitle, rawContent) {
            let content = enforceContentLimits(chineseTitle, rawContent);

            // Apply cm to inch conversion for 'æ¦‚è¦' (Summary) if it contains cm
            if (chineseTitle === 'æ¦‚è¦') {
                content = convertCmToInches(content);
            }

            const regenType = Object.keys(REGEN_TYPE_MAP).find(key => REGEN_TYPE_MAP[key] === chineseTitle);
            
            const validationResult = validateContent(chineseTitle, content);
            const status = getValidationStatus(validationResult);

            // Buttons for interaction
            const lockButton = `<button class="lock-btn action-btn" title="ç‚¹å‡»é”å®š" data-type="${regenType}"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2m3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2"/></svg><span>è§£é”</span></button>`;
            const translateButton = `<button class="translate-btn action-btn" title="åœ¨è°·æ­Œç¿»è¯‘ä¸­æ‰“å¼€"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M4.545 6.714 4.11 8H3l1.862-5h1.284L8 8H6.833l-.435-1.286zm1.634-2.736L5.5 1.956h-.043l-.697 2.022z"/><path d="M0 2a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v3h3a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3H2a2 2 0 0 1-2-2zm2-1a1 1 0 0 0-1 1v7a1 1 0 = 0 1 1h7a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zm7.138 9.995c.193.301.402.583.63.846-.748.575-1.673 1.001-2.768 1.292.178.217.451.635.555.867 1.125-.359 2.08-.844 2.886-1.494.17.302.278.632.365.992.508-.283.92-1.075 1.21-1.96.28-.85.455-1.85.508-2.934h-1.025c-.05.88-.17 1.56-.34 2.11a2.7 2.7 0 0 1-.62 1.087c-.22.252-.494.456-.79.612z"/></svg><span>ç¿»è¯‘</span></button>`;
            const copyButton = `<button class="copy-btn action-btn" title="å¤åˆ¶å†…å®¹"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/><path d="M5.5 1a.5.5 0 0 1 .5.5V2h6v-.5a.5.5 0 0 1 1 0V2A1.5 1.5 0 0 1 11.5 3.5h-7A1.5 1.5 0 0 1 3 2V1.5a.5.5 0 0 1 .5-.5zM5 3.5a.5.5 0 0 0 .5.5h5a.5.5 0 0 0 0-1h-5a.5.5 0 0 0-.5.5"/></svg><span>å¤åˆ¶</span></button>`;
            const regenButton = `<button class="regenerate-btn action-btn" data-type="${regenType}" title="é‡æ–°ç”Ÿæˆæ­¤ç‰ˆå—"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg><span>é‡æ–°ç”Ÿæˆ</span>`;
            const counterDiv = createCounterDiv(chineseTitle, content);

            return `<div class="section-wrapper" id="section-${chineseTitle.replace(/\s/g, '-')}">
                        <h4>
                            <span>${chineseTitle}</span>
                            <span class="validation-status">${status}</span>
                            <div class="ml-auto flex items-center gap-2">${lockButton}${translateButton}${copyButton}${regenButton}</div>
                        </h4>
                        <div class="content-block">
                            ${content.replace(/\n/g, '<br>')}
                            ${counterDiv ? counterDiv.outerHTML : ''}
                        </div>
                     </div>`;
        }

        // Parse new AI generated text and merge with existing locked content
        function parseAndMergeResults(newText, lockedContentMap, productIdea) {
            let html = `<h3>${productIdea}</h3>`;
            const allTypes = ['title', 'description', 'summary', 'keywords'];
            
            const newSections = new Map();
            const startIndex = newText ? newText.indexOf('###') : -1;
            
            if (startIndex !== -1) {
                const cleanText = newText.substring(startIndex);
                const sections = cleanText.split(/### (Title|Summary|Description|Keywords)\n---/g).filter(s => s && s.trim() !== '');
                for (let i = 0; i < sections.length; i += 2) {
                     if (sections[i + 1] === undefined) continue; // Skip if content is missing
                     const englishTitle = sections[i].trim();
                     const regenType = englishTitle.toLowerCase();
                     newSections.set(regenType, sections[i+1].trim());
                }
            }

            allTypes.forEach(regenType => {
                if (lockedContentMap.has(regenType)) {
                    html += lockedContentMap.get(regenType); // Use locked content
                } else {
                    const content = newSections.get(regenType) || 'ç”Ÿæˆå¤±è´¥æˆ–æ— å†…å®¹è¿”å›';
                    const chineseTitle = REGEN_TYPE_MAP[regenType];
                    html += buildSectionHtml(chineseTitle, content); // Build new section HTML
                }
            });

            return html;
        }

        // Display the generated result in the output area
        function displayResult(text, type, productIdea = '') {
            placeholder.classList.add('hidden');
            let html = `<h3>${productIdea}</h3>`;
            const startIndex = text ? text.indexOf('###') : -1;
            
            if (type === 'error') {
                html += `<div class="content-block text-red-600">${text}</div>`;
            } else if (startIndex === -1) {
                html += `<h4>AI åŸå§‹å›å¤ (æ ¼å¼é”™è¯¯)</h4><div class="content-block">${text || 'æ— å†…å®¹è¿”å›'}</div>`;
            } else {
                const cleanText = text.substring(startIndex);
                // Split by markdown headers
                const sections = cleanText.split(/### (Title|Summary|Description|Keywords)\n---/g).filter(s => s && s.trim() !== '');
                
                for (let i = 0; i < sections.length; i += 2) {
                    const englishTitle = sections[i].trim();
                     if (sections[i + 1] === undefined) {
                        console.warn(`Content missing for section: ${englishTitle}`);
                        continue; 
                    }
                    const content = sections[i + 1].trim();
                    const chineseTitle = ENGLISH_TITLE_MAP[englishTitle] || englishTitle;
                    html += buildSectionHtml(chineseTitle, content); // Build HTML for each section
                }
            }
            resultDiv.innerHTML = html;
        }

        // Convert displayed HTML content back to structured plain text for history
        function convertHtmlToStructuredText(htmlContent) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            let structuredText = '';
            const sections = tempDiv.querySelectorAll('.section-wrapper');
            sections.forEach(section => {
                const chineseTitle = section.querySelector('h4 span:first-child').textContent.trim();
                const englishTitle = REVERSE_ENGLISH_TITLE_MAP[chineseTitle] || chineseTitle;
                const content = getCleanTextFromBlock(section.querySelector('.content-block'));
                structuredText += `### ${englishTitle}\n---\n${content}\n\n`;
            });
            return structuredText.trim();
        }

        // Show a temporary message box
        function showMessage(message, type = 'success') {
            messageText.textContent = message;
            messageBox.className = 'fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg fade-in';
            if (type === 'error') messageBox.classList.add('bg-red-500');
            else if (type === 'info') messageBox.classList.add('bg-blue-500');
            else messageBox.classList.add('bg-green-500');
            
            setTimeout(() => { messageBox.classList.add('hidden'); }, 3000);
        }

        // Convert Data URL to File object
        function dataURLtoFile(dataurl, filename) {
            var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){ u8arr[n] = bstr.charCodeAt(n); } 
            return new File([u8arr], filename, {type:mime});
        }
        
        // Parse content string into an object for Excel export
        function parseContentToObject(contentString) {
            const data = {
                'äº§å“åç§°': '', 'äº§å“æè¿°': '', 'æ¦‚è¦': '', 'å…³é”®è¯': '',
            };
            if (!contentString) return data;

            const sections = contentString.split(/### (Title|Description|Summary|Keywords)\n---/g).filter(s => s && s.trim() !== '');

            for (let i = 0; i < sections.length; i += 2) {
                const englishTitle = sections[i].trim();
                const content = sections[i + 1] ? sections[i+1].trim() : '';
                const chineseTitle = ENGLISH_TITLE_MAP[englishTitle];
                if (chineseTitle) {
                    data[chineseTitle] = enforceContentLimits(chineseTitle, content);
                }
            }
            return data;
        }

        // Export history items to an Excel file
        function exportToExcel(items) {
            if (!items || items.length === 0) {
                showMessage('æ²¡æœ‰å¯å¯¼å‡ºçš„å†å²è®°å½•ã€‚', 'info');
                return;
            }

            const dataForSheet = items.map(item => {
                const parsedData = parseContentToObject(item.content);
                return {
                    'äº§å“æ¦‚å¿µ': item.product,
                    'äº§å“åç§°': parsedData['äº§å“åç§°'],
                    'äº§å“æè¿°': parsedData['äº§å“æè¿°'],
                    'æ¦‚è¦': parsedData['æ¦‚è¦'],
                    'å…³é”®è¯': parsedData['å…³é”®è¯'],
                };
            });

            const worksheet = XLSX.utils.json_to_sheet(dataForSheet);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'ASI Products');

            // Set column widths for better readability
            worksheet["!cols"] = [
                { wch: 30 }, { wch: 50 }, { wch: 80 }, { wch: 50 }, { wch: 80 },
            ];

            // Apply wrap text style to all cells for better readability
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            for (let R = range.s.r; R <= range.e.r; ++R) { 
                for(let C = range.s.c; C <= range.e.c; ++C) {
                    const cell_address = { c: C, r: R };
                    const cell_ref = XLSX.utils.encode_cell(cell_address);
                    if (worksheet[cell_ref] && worksheet[cell_ref].t === 's') { 
                        if (!worksheet[cell_ref].s) worksheet[cell_ref].s = {};
                        worksheet[cell_ref].s.alignment = { wrapText: true, vertical: 'top', horizontal: 'left' };
                    }
                }
            }

            XLSX.writeFile(workbook, `ASI_Export_${new Date().toISOString().slice(0,10)}.xlsx`);
            showMessage('å¯¼å‡ºæˆåŠŸï¼', 'success');
        }

        // Call Gemini API with retry logic
        async function callGeminiAPI(prompt, base64Data, mimeType) {
            const userApiKey = localStorage.getItem('geminiApiKey');
            if (!userApiKey) {
                throw new Error('APIå¯†é’¥æœªé…ç½®ã€‚');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${userApiKey}`;
            const userParts = [{ text: prompt }];
            if (base64Data && mimeType) {
                userParts.unshift({ inlineData: { mimeType: mimeType, data: base64Data } });
            }
            
            const payload = {
                contents: [{ role: "user", parts: userParts }],
                generationConfig: { temperature: 0.6, topP: 1.0, maxOutputTokens: 8192 }
            };

            const MAX_RETRIES = 3; // Maximum number of retries
            const BASE_DELAY_MS = 1000; // Base delay in milliseconds (1 second)

            for (let i = 0; i <= MAX_RETRIES; i++) {
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) {
                        let errorBody = 'æ— æ³•è¯»å–é”™è¯¯è¯¦æƒ…';
                        try {
                            const errorJson = await response.json();
                            errorBody = errorJson?.error?.message || response.statusText;
                            
                            // Specific handling for API key invalidation
                            if(errorJson?.error?.status === 'INVALID_ARGUMENT' && errorJson?.error?.message.includes("API_KEY_INVALID") || errorBody.includes('API key expired')){
                                throw new Error('APIå¯†é’¥æ— æ•ˆ (INVALID_ARGUMENT)ã€‚è¯·æ£€æŸ¥æ‚¨çš„å¯†é’¥ã€‚');
                            }

                            // Retry logic for 5xx errors or specific overload messages
                            if (response.status >= 500 || errorBody.includes('The model is overloaded')) {
                                if (i < MAX_RETRIES) {
                                    const delay = BASE_DELAY_MS * Math.pow(2, i); // Exponential backoff
                                    console.warn(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${errorBody}. æ­£åœ¨é‡è¯•... (å»¶è¿Ÿ ${delay / 1000}ç§’)`);
                                    await new Promise(resolve => setTimeout(resolve, delay));
                                    continue; // Retry the request
                                }
                            }
                        } catch(e) {
                            if (e.message.includes('APIå¯†é’¥æ— æ•ˆ')) throw e; // Re-throw API key error immediately
                            try { errorBody = await response.text(); } catch(e2) { /* ignore */}
                        }
                        // If not a retryable error or max retries reached, throw the error
                        throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${errorBody}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    
                    if (candidate?.content?.parts?.[0]?.text) {
                         if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                            console.warn(`API response may be partial. Reason: ${candidate.finishReason}`);
                         }
                         return candidate.content.parts[0].text.trim();
                    }

                    if (candidate) {
                        const finishReason = candidate.finishReason || 'æœªçŸ¥';
                        switch (finishReason) {
                            case 'SAFETY':
                                throw new Error("å†…å®¹å¯èƒ½è¿åäº†å®‰å…¨ç­–ç•¥ï¼Œè¯·ä¿®æ”¹è¾“å…¥åé‡è¯•ã€‚");
                            case 'MAX_TOKENS':
                                throw new Error("å†…å®¹ç”Ÿæˆè¶…å‡ºæœ€å¤§é•¿åº¦é™åˆ¶ï¼Œè¯·å°è¯•ç®€åŒ–è¾“å…¥æˆ–å‚è€ƒæ–‡æ¡ˆã€‚");
                            case 'RECITATION':
                                throw new Error("å†…å®¹å› å¼•ç”¨å—ç‰ˆæƒä¿æŠ¤çš„ææ–™è€Œè¢«é˜»æ­¢ã€‚");
                            default:
                                throw new Error(`AIæœªèƒ½ç”Ÿæˆæœ‰æ•ˆå†…å®¹ã€‚åŸå› : ${finishReason}`);
                        }
                    }
                    
                    throw new Error("AIæœªèƒ½ç”Ÿæˆæœ‰æ•ˆå†…å®¹ï¼ŒAPIæœªè¿”å›ä»»ä½•å€™é€‰ç»“æœã€‚");

                } catch (error) {
                    // If the error is an API key error, re-throw it immediately without retry
                    if (error.message.includes('APIå¯†é’¥æ— æ•ˆ')) {
                        throw error;
                    }
                    // For other errors, if max retries reached, re-throw
                    if (i === MAX_RETRIES) {
                        throw error;
                    }
                    // Otherwise, log and continue to the next retry (handled by the loop)
                    console.error(`å°è¯• ${i + 1}/${MAX_RETRIES + 1} å¤±è´¥:`, error.message);
                }
            }
            // Should not be reached, but as a fallback
            throw new Error("APIè¯·æ±‚åœ¨å¤šæ¬¡é‡è¯•åä»ç„¶å¤±è´¥ã€‚");
        }
    </script>
</body>
</html>
